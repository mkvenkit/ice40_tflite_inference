
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.15+40 (git sha1 e1d4863a1, clang 10.0.0-4ubuntu1 -fPIC -Os)


-- Parsing `top.v' using frontend ` -vlog2k' --

1. Executing Verilog-2005 frontend: top.v
Parsing Verilog input from `top.v' to AST representation.
Storing AST representation for module `$abstract\top'.
Successfully finished Verilog frontend.

-- Parsing `matmul.v' using frontend ` -vlog2k' --

2. Executing Verilog-2005 frontend: matmul.v
Parsing Verilog input from `matmul.v' to AST representation.
Storing AST representation for module `$abstract\matmul'.
Successfully finished Verilog frontend.

-- Running command `synth_ice40 -dsp -top top -json matmul.json' --

3. Executing SYNTH_ICE40 pass.

3.1. Executing Verilog-2005 frontend: /home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v
Parsing Verilog input from `/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\SB_IO'.
Generating RTLIL representation for module `\SB_GB_IO'.
Generating RTLIL representation for module `\SB_GB'.
Generating RTLIL representation for module `\SB_LUT4'.
Generating RTLIL representation for module `\SB_CARRY'.
Generating RTLIL representation for module `\SB_DFF'.
Generating RTLIL representation for module `\SB_DFFE'.
Generating RTLIL representation for module `\SB_DFFSR'.
Generating RTLIL representation for module `\SB_DFFR'.
Generating RTLIL representation for module `\SB_DFFSS'.
Generating RTLIL representation for module `\SB_DFFS'.
Generating RTLIL representation for module `\SB_DFFESR'.
Generating RTLIL representation for module `\SB_DFFER'.
Generating RTLIL representation for module `\SB_DFFESS'.
Generating RTLIL representation for module `\SB_DFFES'.
Generating RTLIL representation for module `\SB_DFFN'.
Generating RTLIL representation for module `\SB_DFFNE'.
Generating RTLIL representation for module `\SB_DFFNSR'.
Generating RTLIL representation for module `\SB_DFFNR'.
Generating RTLIL representation for module `\SB_DFFNSS'.
Generating RTLIL representation for module `\SB_DFFNS'.
Generating RTLIL representation for module `\SB_DFFNESR'.
Generating RTLIL representation for module `\SB_DFFNER'.
Generating RTLIL representation for module `\SB_DFFNESS'.
Generating RTLIL representation for module `\SB_DFFNES'.
Generating RTLIL representation for module `\SB_RAM40_4K'.
Generating RTLIL representation for module `\SB_RAM40_4KNR'.
Generating RTLIL representation for module `\SB_RAM40_4KNW'.
Generating RTLIL representation for module `\SB_RAM40_4KNRNW'.
Generating RTLIL representation for module `\ICESTORM_LC'.
Generating RTLIL representation for module `\SB_PLL40_CORE'.
Generating RTLIL representation for module `\SB_PLL40_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2F_CORE'.
Generating RTLIL representation for module `\SB_PLL40_2F_PAD'.
Generating RTLIL representation for module `\SB_WARMBOOT'.
Generating RTLIL representation for module `\SB_SPRAM256KA'.
Generating RTLIL representation for module `\SB_HFOSC'.
Generating RTLIL representation for module `\SB_LFOSC'.
Generating RTLIL representation for module `\SB_RGBA_DRV'.
Generating RTLIL representation for module `\SB_LED_DRV_CUR'.
Generating RTLIL representation for module `\SB_RGB_DRV'.
Generating RTLIL representation for module `\SB_I2C'.
Generating RTLIL representation for module `\SB_SPI'.
Generating RTLIL representation for module `\SB_LEDDA_IP'.
Generating RTLIL representation for module `\SB_FILTER_50NS'.
Generating RTLIL representation for module `\SB_IO_I3C'.
Generating RTLIL representation for module `\SB_IO_OD'.
Generating RTLIL representation for module `\SB_MAC16'.
Generating RTLIL representation for module `\ICESTORM_RAM'.
Successfully finished Verilog frontend.

3.2. Executing HIERARCHY pass (managing design hierarchy).

3.3. Executing AST frontend in derive mode using pre-parsed AST for module `\top'.
Generating RTLIL representation for module `\top'.

3.3.1. Analyzing design hierarchy..
Top module:  \top

3.3.2. Executing AST frontend in derive mode using pre-parsed AST for module `\matmul'.
Generating RTLIL representation for module `\matmul'.
Warning: Replacing memory \sum with list of registers. See matmul.v:81

3.3.3. Analyzing design hierarchy..
Top module:  \top
Used module:     \matmul

3.3.4. Analyzing design hierarchy..
Top module:  \top
Used module:     \matmul
Removing unused module `$abstract\matmul'.
Removing unused module `$abstract\top'.
Removed 2 unused modules.

3.4. Executing PROC pass (convert processes to netlists).

3.4.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.4.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1386$249 in module SB_DFFNES.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1328$242 in module SB_DFFNESS.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1251$238 in module SB_DFFNER.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1193$231 in module SB_DFFNESR.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1122$228 in module SB_DFFNS.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1072$225 in module SB_DFFNSS.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1001$222 in module SB_DFFNR.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:951$219 in module SB_DFFNSR.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:789$211 in module SB_DFFES.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:731$204 in module SB_DFFESS.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:654$200 in module SB_DFFER.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:596$193 in module SB_DFFESR.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:525$190 in module SB_DFFS.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:475$187 in module SB_DFFSS.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:404$184 in module SB_DFFR.
Marked 1 switch rules as full_case in process $proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:354$181 in module SB_DFFSR.
Marked 6 switch rules as full_case in process $proc$matmul.v:75$466 in module matmul.
Marked 1 switch rules as full_case in process $proc$top.v:34$393 in module top.
Removed a total of 0 dead cases.

3.4.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 9 redundant assignments.
Promoted 83 assignments to connections.

3.4.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\SB_DFFNES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$252'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$248'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$241'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$237'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$230'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$227'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$224'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$221'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFNE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$218'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFN.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$216'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$214'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$210'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$203'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$199'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$192'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$189'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$186'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$183'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFFE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$180'.
  Set init value: \Q = 1'0
Found init rule in `\SB_DFF.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$178'.
  Set init value: \Q = 1'0
Found init rule in `\matmul.$proc$matmul.v:0$637'.
  Set init value: \i = 10
Found init rule in `\top.$proc$top.v:20$399'.
  Set init value: \resetn_counter = 8'00000000

3.4.5. Executing PROC_ARST pass (detect async resets in processes).
Found async reset \S in `\SB_DFFNES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1386$249'.
Found async reset \R in `\SB_DFFNER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1251$238'.
Found async reset \S in `\SB_DFFNS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1122$228'.
Found async reset \R in `\SB_DFFNR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1001$222'.
Found async reset \S in `\SB_DFFES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:789$211'.
Found async reset \R in `\SB_DFFER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:654$200'.
Found async reset \S in `\SB_DFFS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:525$190'.
Found async reset \R in `\SB_DFFR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:404$184'.

3.4.6. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\SB_DFFNES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$252'.
Creating decoders for process `\SB_DFFNES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1386$249'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$248'.
Creating decoders for process `\SB_DFFNESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1328$242'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$241'.
Creating decoders for process `\SB_DFFNER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1251$238'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$237'.
Creating decoders for process `\SB_DFFNESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1193$231'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$230'.
Creating decoders for process `\SB_DFFNS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1122$228'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$227'.
Creating decoders for process `\SB_DFFNSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1072$225'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$224'.
Creating decoders for process `\SB_DFFNR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1001$222'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$221'.
Creating decoders for process `\SB_DFFNSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:951$219'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFNE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$218'.
Creating decoders for process `\SB_DFFNE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:906$217'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFN.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$216'.
Creating decoders for process `\SB_DFFN.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:868$215'.
Creating decoders for process `\SB_DFFES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$214'.
Creating decoders for process `\SB_DFFES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:789$211'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$210'.
Creating decoders for process `\SB_DFFESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:731$204'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$203'.
Creating decoders for process `\SB_DFFER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:654$200'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$199'.
Creating decoders for process `\SB_DFFESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:596$193'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$192'.
Creating decoders for process `\SB_DFFS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:525$190'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$189'.
Creating decoders for process `\SB_DFFSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:475$187'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$186'.
Creating decoders for process `\SB_DFFR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:404$184'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$183'.
Creating decoders for process `\SB_DFFSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:354$181'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFFE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$180'.
Creating decoders for process `\SB_DFFE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:309$179'.
     1/1: $0\Q[0:0]
Creating decoders for process `\SB_DFF.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$178'.
Creating decoders for process `\SB_DFF.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:271$177'.
Creating decoders for process `\matmul.$proc$matmul.v:0$637'.
Creating decoders for process `\matmul.$proc$matmul.v:75$466'.
     1/34: $4\i[31:0]
     2/34: $3\i[31:0]
     3/34: $3$memwr$\C$matmul.v:98$453_EN[31:0]$492
     4/34: $3$memwr$\C$matmul.v:98$452_EN[31:0]$491
     5/34: $3$memwr$\C$matmul.v:98$451_EN[31:0]$490
     6/34: $3$memwr$\C$matmul.v:98$450_EN[31:0]$489
     7/34: $2$memwr$\C$matmul.v:98$453_EN[31:0]$485
     8/34: $2$memwr$\C$matmul.v:98$452_EN[31:0]$484
     9/34: $2$memwr$\C$matmul.v:98$451_EN[31:0]$483
    10/34: $2$memwr$\C$matmul.v:98$450_EN[31:0]$482
    11/34: $2\i[31:0]
    12/34: $2$memwr$\C$matmul.v:151$454_EN[31:0]$488
    13/34: $2$memwr$\C$matmul.v:151$454_DATA[31:0]$487
    14/34: $2$memwr$\C$matmul.v:151$454_ADDR[2:0]$486
    15/34: $1\i[31:0]
    16/34: $1$memwr$\C$matmul.v:151$454_EN[31:0]$481
    17/34: $1$memwr$\C$matmul.v:151$454_DATA[31:0]$480
    18/34: $1$memwr$\C$matmul.v:151$454_ADDR[2:0]$479
    19/34: $1$memwr$\C$matmul.v:98$453_EN[31:0]$478
    20/34: $1$memwr$\C$matmul.v:98$452_EN[31:0]$477
    21/34: $1$memwr$\C$matmul.v:98$451_EN[31:0]$476
    22/34: $1$memwr$\C$matmul.v:98$450_EN[31:0]$475
    23/34: $0\sum[7][31:0]
    24/34: $0\sum[6][31:0]
    25/34: $0\sum[5][31:0]
    26/34: $0\sum[4][31:0]
    27/34: $0\sum[3][31:0]
    28/34: $0\sum[2][31:0]
    29/34: $0\sum[1][31:0]
    30/34: $0\sum[0][31:0]
    31/34: $0\row_index[2:0]
    32/34: $0\index[7:0]
    33/34: $0\state[2:0]
    34/34: $0\D[31:0]
Creating decoders for process `\top.$proc$top.v:20$399'.
Creating decoders for process `\top.$proc$top.v:34$393'.
     1/2: $0\counter[22:0]
     2/2: $0\RL[0:0]
Creating decoders for process `\top.$proc$top.v:23$390'.
     1/1: $0\resetn_counter[7:0]

3.4.7. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\matmul.\j' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$400_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$401_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$402_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$403_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$404_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$405_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$406_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$407_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$408_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$409_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$410_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$411_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$412_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$413_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$414_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$415_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$416_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$417_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$418_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$419_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$420_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$421_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$422_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$423_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$424_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$425_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$426_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$427_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$428_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$429_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$430_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$431_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$432_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$433_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$434_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$435_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$436_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$437_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$438_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\A$matmul.v:35$439_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\B$matmul.v:38$440_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\B$matmul.v:38$441_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\B$matmul.v:38$442_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\B$matmul.v:38$443_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\B$matmul.v:38$444_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\B$matmul.v:38$445_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\B$matmul.v:38$446_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\B$matmul.v:38$447_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\B$matmul.v:38$448_EN' from process `\matmul.$proc$matmul.v:0$637'.
No latch inferred for signal `\matmul.$memwr$\B$matmul.v:38$449_EN' from process `\matmul.$proc$matmul.v:0$637'.

3.4.8. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\SB_DFFNES.\Q' using process `\SB_DFFNES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1386$249'.
  created $adff cell `$procdff$1053' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNESS.\Q' using process `\SB_DFFNESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1328$242'.
  created $dff cell `$procdff$1054' with negative edge clock.
Creating register for signal `\SB_DFFNER.\Q' using process `\SB_DFFNER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1251$238'.
  created $adff cell `$procdff$1055' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNESR.\Q' using process `\SB_DFFNESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1193$231'.
  created $dff cell `$procdff$1056' with negative edge clock.
Creating register for signal `\SB_DFFNS.\Q' using process `\SB_DFFNS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1122$228'.
  created $adff cell `$procdff$1057' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNSS.\Q' using process `\SB_DFFNSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1072$225'.
  created $dff cell `$procdff$1058' with negative edge clock.
Creating register for signal `\SB_DFFNR.\Q' using process `\SB_DFFNR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1001$222'.
  created $adff cell `$procdff$1059' with negative edge clock and positive level reset.
Creating register for signal `\SB_DFFNSR.\Q' using process `\SB_DFFNSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:951$219'.
  created $dff cell `$procdff$1060' with negative edge clock.
Creating register for signal `\SB_DFFNE.\Q' using process `\SB_DFFNE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:906$217'.
  created $dff cell `$procdff$1061' with negative edge clock.
Creating register for signal `\SB_DFFN.\Q' using process `\SB_DFFN.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:868$215'.
  created $dff cell `$procdff$1062' with negative edge clock.
Creating register for signal `\SB_DFFES.\Q' using process `\SB_DFFES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:789$211'.
  created $adff cell `$procdff$1063' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFESS.\Q' using process `\SB_DFFESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:731$204'.
  created $dff cell `$procdff$1064' with positive edge clock.
Creating register for signal `\SB_DFFER.\Q' using process `\SB_DFFER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:654$200'.
  created $adff cell `$procdff$1065' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFESR.\Q' using process `\SB_DFFESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:596$193'.
  created $dff cell `$procdff$1066' with positive edge clock.
Creating register for signal `\SB_DFFS.\Q' using process `\SB_DFFS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:525$190'.
  created $adff cell `$procdff$1067' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFSS.\Q' using process `\SB_DFFSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:475$187'.
  created $dff cell `$procdff$1068' with positive edge clock.
Creating register for signal `\SB_DFFR.\Q' using process `\SB_DFFR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:404$184'.
  created $adff cell `$procdff$1069' with positive edge clock and positive level reset.
Creating register for signal `\SB_DFFSR.\Q' using process `\SB_DFFSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:354$181'.
  created $dff cell `$procdff$1070' with positive edge clock.
Creating register for signal `\SB_DFFE.\Q' using process `\SB_DFFE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:309$179'.
  created $dff cell `$procdff$1071' with positive edge clock.
Creating register for signal `\SB_DFF.\Q' using process `\SB_DFF.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:271$177'.
  created $dff cell `$procdff$1072' with positive edge clock.
Creating register for signal `\matmul.\D' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1073' with positive edge clock.
Creating register for signal `\matmul.\i' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1074' with positive edge clock.
Creating register for signal `\matmul.\state' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1075' with positive edge clock.
Creating register for signal `\matmul.\index' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1076' with positive edge clock.
Creating register for signal `\matmul.\row_index' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1077' with positive edge clock.
Creating register for signal `\matmul.\sum[0]' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1078' with positive edge clock.
Creating register for signal `\matmul.\sum[1]' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1079' with positive edge clock.
Creating register for signal `\matmul.\sum[2]' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1080' with positive edge clock.
Creating register for signal `\matmul.\sum[3]' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1081' with positive edge clock.
Creating register for signal `\matmul.\sum[4]' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1082' with positive edge clock.
Creating register for signal `\matmul.\sum[5]' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1083' with positive edge clock.
Creating register for signal `\matmul.\sum[6]' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1084' with positive edge clock.
Creating register for signal `\matmul.\sum[7]' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1085' with positive edge clock.
Creating register for signal `\matmul.$memwr$\C$matmul.v:98$450_EN' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1086' with positive edge clock.
Creating register for signal `\matmul.$memwr$\C$matmul.v:98$451_EN' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1087' with positive edge clock.
Creating register for signal `\matmul.$memwr$\C$matmul.v:98$452_EN' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1088' with positive edge clock.
Creating register for signal `\matmul.$memwr$\C$matmul.v:98$453_EN' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1089' with positive edge clock.
Creating register for signal `\matmul.$memwr$\C$matmul.v:151$454_ADDR' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1090' with positive edge clock.
Creating register for signal `\matmul.$memwr$\C$matmul.v:151$454_DATA' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1091' with positive edge clock.
Creating register for signal `\matmul.$memwr$\C$matmul.v:151$454_EN' using process `\matmul.$proc$matmul.v:75$466'.
  created $dff cell `$procdff$1092' with positive edge clock.
Creating register for signal `\top.\RL' using process `\top.$proc$top.v:34$393'.
  created $dff cell `$procdff$1093' with positive edge clock.
Creating register for signal `\top.\counter' using process `\top.$proc$top.v:34$393'.
  created $dff cell `$procdff$1094' with positive edge clock.
Creating register for signal `\top.\resetn_counter' using process `\top.$proc$top.v:23$390'.
  created $dff cell `$procdff$1095' with positive edge clock.

3.4.9. Executing PROC_MEMWR pass (convert process memory writes to cells).

3.4.10. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `SB_DFFNES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$252'.
Found and cleaned up 1 empty switch in `\SB_DFFNES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1386$249'.
Removing empty process `SB_DFFNES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1386$249'.
Removing empty process `SB_DFFNESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$248'.
Found and cleaned up 2 empty switches in `\SB_DFFNESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1328$242'.
Removing empty process `SB_DFFNESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1328$242'.
Removing empty process `SB_DFFNER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$241'.
Found and cleaned up 1 empty switch in `\SB_DFFNER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1251$238'.
Removing empty process `SB_DFFNER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1251$238'.
Removing empty process `SB_DFFNESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$237'.
Found and cleaned up 2 empty switches in `\SB_DFFNESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1193$231'.
Removing empty process `SB_DFFNESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1193$231'.
Removing empty process `SB_DFFNS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$230'.
Removing empty process `SB_DFFNS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1122$228'.
Removing empty process `SB_DFFNSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$227'.
Found and cleaned up 1 empty switch in `\SB_DFFNSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1072$225'.
Removing empty process `SB_DFFNSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1072$225'.
Removing empty process `SB_DFFNR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$224'.
Removing empty process `SB_DFFNR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:1001$222'.
Removing empty process `SB_DFFNSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$221'.
Found and cleaned up 1 empty switch in `\SB_DFFNSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:951$219'.
Removing empty process `SB_DFFNSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:951$219'.
Removing empty process `SB_DFFNE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$218'.
Found and cleaned up 1 empty switch in `\SB_DFFNE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:906$217'.
Removing empty process `SB_DFFNE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:906$217'.
Removing empty process `SB_DFFN.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$216'.
Removing empty process `SB_DFFN.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:868$215'.
Removing empty process `SB_DFFES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$214'.
Found and cleaned up 1 empty switch in `\SB_DFFES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:789$211'.
Removing empty process `SB_DFFES.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:789$211'.
Removing empty process `SB_DFFESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$210'.
Found and cleaned up 2 empty switches in `\SB_DFFESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:731$204'.
Removing empty process `SB_DFFESS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:731$204'.
Removing empty process `SB_DFFER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$203'.
Found and cleaned up 1 empty switch in `\SB_DFFER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:654$200'.
Removing empty process `SB_DFFER.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:654$200'.
Removing empty process `SB_DFFESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$199'.
Found and cleaned up 2 empty switches in `\SB_DFFESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:596$193'.
Removing empty process `SB_DFFESR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:596$193'.
Removing empty process `SB_DFFS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$192'.
Removing empty process `SB_DFFS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:525$190'.
Removing empty process `SB_DFFSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$189'.
Found and cleaned up 1 empty switch in `\SB_DFFSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:475$187'.
Removing empty process `SB_DFFSS.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:475$187'.
Removing empty process `SB_DFFR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$186'.
Removing empty process `SB_DFFR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:404$184'.
Removing empty process `SB_DFFSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$183'.
Found and cleaned up 1 empty switch in `\SB_DFFSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:354$181'.
Removing empty process `SB_DFFSR.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:354$181'.
Removing empty process `SB_DFFE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$180'.
Found and cleaned up 1 empty switch in `\SB_DFFE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:309$179'.
Removing empty process `SB_DFFE.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:309$179'.
Removing empty process `SB_DFF.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:0$178'.
Removing empty process `SB_DFF.$proc$/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_sim.v:271$177'.
Removing empty process `matmul.$proc$matmul.v:0$637'.
Found and cleaned up 6 empty switches in `\matmul.$proc$matmul.v:75$466'.
Removing empty process `matmul.$proc$matmul.v:75$466'.
Removing empty process `top.$proc$top.v:20$399'.
Found and cleaned up 2 empty switches in `\top.$proc$top.v:34$393'.
Removing empty process `top.$proc$top.v:34$393'.
Found and cleaned up 1 empty switch in `\top.$proc$top.v:23$390'.
Removing empty process `top.$proc$top.v:23$390'.
Cleaned up 27 empty switches.

3.4.11. Executing OPT_EXPR pass (perform const folding).
Optimizing module matmul.
<suppressed ~56 debug messages>
Optimizing module top.
<suppressed ~3 debug messages>

3.5. Executing FLATTEN pass (flatten design).
Deleting now unused module matmul.
<suppressed ~1 debug messages>

3.6. Executing TRIBUF pass.

3.7. Executing DEMINOUT pass (demote inout ports to input or output).

3.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~49 debug messages>

3.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 81 unused cells and 320 unused wires.
<suppressed ~92 debug messages>

3.10. Executing CHECK pass (checking for obvious problems).
Checking module top...
Found and reported 0 problems.

3.11. Executing OPT pass (performing simple optimizations).

3.11.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.11.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
<suppressed ~150 debug messages>
Removed a total of 50 cells.

3.11.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~13 debug messages>

3.11.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
    New ctrl vector for $pmux cell $flatten\m1.$procmux$1032: { $flatten\m1.$procmux$1019_CMP $flatten\m1.$procmux$1000_CMP $auto$opt_reduce.cc:134:opt_pmux$1102 }
    New ctrl vector for $pmux cell $flatten\m1.$procmux$900: { $flatten\m1.$procmux$1004_CMP $auto$opt_reduce.cc:134:opt_pmux$1104 }
    New ctrl vector for $pmux cell $flatten\m1.$procmux$911: { $flatten\m1.$procmux$1004_CMP $auto$opt_reduce.cc:134:opt_pmux$1106 }
    New ctrl vector for $pmux cell $flatten\m1.$procmux$922: { $flatten\m1.$procmux$1004_CMP $auto$opt_reduce.cc:134:opt_pmux$1108 }
    New ctrl vector for $pmux cell $flatten\m1.$procmux$933: { $flatten\m1.$procmux$1004_CMP $auto$opt_reduce.cc:134:opt_pmux$1110 }
    New ctrl vector for $pmux cell $flatten\m1.$procmux$944: { $flatten\m1.$procmux$1004_CMP $auto$opt_reduce.cc:134:opt_pmux$1112 }
    New ctrl vector for $pmux cell $flatten\m1.$procmux$955: { $flatten\m1.$procmux$1004_CMP $auto$opt_reduce.cc:134:opt_pmux$1114 }
    New ctrl vector for $pmux cell $flatten\m1.$procmux$966: { $flatten\m1.$procmux$1004_CMP $auto$opt_reduce.cc:134:opt_pmux$1116 }
    New ctrl vector for $pmux cell $flatten\m1.$procmux$977: { $flatten\m1.$procmux$1004_CMP $auto$opt_reduce.cc:134:opt_pmux$1118 }
    New ctrl vector for $pmux cell $flatten\m1.$procmux$995: { $flatten\m1.$procmux$1004_CMP $flatten\m1.$procmux$1000_CMP $auto$opt_reduce.cc:134:opt_pmux$1120 }
  Optimizing cells in module \top.
Performed a total of 10 changes.

3.11.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
<suppressed ~27 debug messages>
Removed a total of 9 cells.

3.11.6. Executing OPT_DFF pass (perform DFF optimizations).

3.11.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 0 unused cells and 59 unused wires.
<suppressed ~1 debug messages>

3.11.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.11.9. Rerunning OPT passes. (Maybe there is more to do..)

3.11.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~13 debug messages>

3.11.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
Performed a total of 0 changes.

3.11.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.11.13. Executing OPT_DFF pass (perform DFF optimizations).

3.11.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

3.11.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.11.16. Finished OPT passes. (There is nothing left to do.)

3.12. Executing FSM pass (extract and optimize FSM).

3.12.1. Executing FSM_DETECT pass (finding FSMs in design).
Found FSM state register top.m1.state.

3.12.2. Executing FSM_EXTRACT pass (extracting FSM from design).
Extracting FSM `\m1.state' from module `\top'.
  found $dff cell for state register: $flatten\m1.$procdff$1075
  root of input selection tree: $flatten\m1.$0\state[2:0]
  found reset state: 3'000 (guessed from mux tree)
  found ctrl input: \m1.resetn
  found state code: 3'000
  found ctrl input: $flatten\m1.$procmux$1014_CMP
  found ctrl input: $flatten\m1.$procmux$1000_CMP
  found ctrl input: $flatten\m1.$procmux$1019_CMP
  found ctrl input: $flatten\m1.$procmux$1004_CMP
  found ctrl input: $flatten\m1.$procmux$1005_CMP
  found ctrl input: $flatten\m1.$eq$matmul.v:161$586_Y
  found state code: 3'001
  found ctrl input: $flatten\m1.$lt$matmul.v:140$575_Y
  found state code: 3'100
  found state code: 3'011
  found ctrl input: $flatten\m1.$lt$matmul.v:106$493_Y
  found state code: 3'010
  found ctrl output: $flatten\m1.$procmux$1019_CMP
  found ctrl output: $flatten\m1.$procmux$1014_CMP
  found ctrl output: $flatten\m1.$procmux$1005_CMP
  found ctrl output: $flatten\m1.$procmux$1004_CMP
  found ctrl output: $flatten\m1.$procmux$1000_CMP
  ctrl inputs: { \m1.resetn $flatten\m1.$lt$matmul.v:106$493_Y $flatten\m1.$lt$matmul.v:140$575_Y $flatten\m1.$eq$matmul.v:161$586_Y }
  ctrl outputs: { $flatten\m1.$0\state[2:0] $flatten\m1.$procmux$1000_CMP $flatten\m1.$procmux$1004_CMP $flatten\m1.$procmux$1005_CMP $flatten\m1.$procmux$1014_CMP $flatten\m1.$procmux$1019_CMP }
  transition:      3'000 4'0--- ->      3'000 8'00000100
  transition:      3'000 4'1--- ->      3'001 8'00100100
  transition:      3'100 4'0--- ->      3'000 8'00000010
  transition:      3'100 4'1--0 ->      3'001 8'00100010
  transition:      3'100 4'1--1 ->      3'000 8'00000010
  transition:      3'010 4'0--- ->      3'000 8'00000001
  transition:      3'010 4'1--- ->      3'011 8'01100001
  transition:      3'001 4'0--- ->      3'000 8'00001000
  transition:      3'001 4'10-- ->      3'010 8'01001000
  transition:      3'001 4'11-- ->      3'001 8'00101000
  transition:      3'011 4'0--- ->      3'000 8'00010000
  transition:      3'011 4'1-0- ->      3'100 8'10010000
  transition:      3'011 4'1-1- ->      3'011 8'01110000

3.12.3. Executing FSM_OPT pass (simple optimizations of FSMs).
Optimizing FSM `$fsm$\m1.state$1121' from module `\top'.

3.12.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 11 unused cells and 11 unused wires.
<suppressed ~12 debug messages>

3.12.5. Executing FSM_OPT pass (simple optimizations of FSMs).
Optimizing FSM `$fsm$\m1.state$1121' from module `\top'.
  Removing unused output signal $flatten\m1.$0\state[2:0] [0].
  Removing unused output signal $flatten\m1.$0\state[2:0] [1].
  Removing unused output signal $flatten\m1.$0\state[2:0] [2].

3.12.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).
Recoding FSM `$fsm$\m1.state$1121' from module `\top' using `auto' encoding:
  mapping auto encoding to `one-hot` for this FSM.
  000 -> ----1
  100 -> ---1-
  010 -> --1--
  001 -> -1---
  011 -> 1----

3.12.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

FSM `$fsm$\m1.state$1121' from module `top':
-------------------------------------

  Information on FSM $fsm$\m1.state$1121 (\m1.state):

  Number of input signals:    4
  Number of output signals:   5
  Number of state bits:       5

  Input signals:
    0: $flatten\m1.$eq$matmul.v:161$586_Y
    1: $flatten\m1.$lt$matmul.v:140$575_Y
    2: $flatten\m1.$lt$matmul.v:106$493_Y
    3: \m1.resetn

  Output signals:
    0: $flatten\m1.$procmux$1019_CMP
    1: $flatten\m1.$procmux$1014_CMP
    2: $flatten\m1.$procmux$1005_CMP
    3: $flatten\m1.$procmux$1004_CMP
    4: $flatten\m1.$procmux$1000_CMP

  State encoding:
    0:    5'----1  <RESET STATE>
    1:    5'---1-
    2:    5'--1--
    3:    5'-1---
    4:    5'1----

  Transition Table (state_in, ctrl_in, state_out, ctrl_out):
      0:     0 4'0---   ->     0 5'00100
      1:     0 4'1---   ->     3 5'00100
      2:     1 4'1--1   ->     0 5'00010
      3:     1 4'0---   ->     0 5'00010
      4:     1 4'1--0   ->     3 5'00010
      5:     2 4'0---   ->     0 5'00001
      6:     2 4'1---   ->     4 5'00001
      7:     3 4'0---   ->     0 5'01000
      8:     3 4'10--   ->     2 5'01000
      9:     3 4'11--   ->     3 5'01000
     10:     4 4'0---   ->     0 5'10000
     11:     4 4'1-0-   ->     1 5'10000
     12:     4 4'1-1-   ->     4 5'10000

-------------------------------------

3.12.8. Executing FSM_MAP pass (mapping FSMs to basic logic).
Mapping FSM `$fsm$\m1.state$1121' from module `\top'.

3.13. Executing OPT pass (performing simple optimizations).

3.13.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~3 debug messages>

3.13.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.13.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~12 debug messages>

3.13.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
Performed a total of 0 changes.

3.13.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.13.6. Executing OPT_DFF pass (perform DFF optimizations).
Adding EN signal on $procdff$1095 ($dff) from module top (D = $add$top.v:27$392_Y [7:0], Q = \resetn_counter).
Adding SRST signal on $flatten\m1.$procdff$1085 ($dff) from module top (D = $flatten\m1.$procmux$900_Y, Q = \m1.sum[7], rval = 0).
Adding EN signal on $auto$ff.cc:262:slice$1170 ($sdff) from module top (D = $flatten\m1.$procmux$900_Y, Q = \m1.sum[7]).
Adding SRST signal on $flatten\m1.$procdff$1084 ($dff) from module top (D = $flatten\m1.$procmux$911_Y, Q = \m1.sum[6], rval = 0).
Adding EN signal on $auto$ff.cc:262:slice$1178 ($sdff) from module top (D = $flatten\m1.$procmux$911_Y, Q = \m1.sum[6]).
Adding SRST signal on $flatten\m1.$procdff$1083 ($dff) from module top (D = $flatten\m1.$procmux$922_Y, Q = \m1.sum[5], rval = 0).
Adding EN signal on $auto$ff.cc:262:slice$1186 ($sdff) from module top (D = $flatten\m1.$procmux$922_Y, Q = \m1.sum[5]).
Adding SRST signal on $flatten\m1.$procdff$1082 ($dff) from module top (D = $flatten\m1.$procmux$933_Y, Q = \m1.sum[4], rval = 0).
Adding EN signal on $auto$ff.cc:262:slice$1194 ($sdff) from module top (D = $flatten\m1.$procmux$933_Y, Q = \m1.sum[4]).
Adding SRST signal on $flatten\m1.$procdff$1081 ($dff) from module top (D = $flatten\m1.$procmux$944_Y, Q = \m1.sum[3], rval = 0).
Adding EN signal on $auto$ff.cc:262:slice$1202 ($sdff) from module top (D = $flatten\m1.$procmux$944_Y, Q = \m1.sum[3]).
Adding SRST signal on $flatten\m1.$procdff$1080 ($dff) from module top (D = $flatten\m1.$procmux$955_Y, Q = \m1.sum[2], rval = 0).
Adding EN signal on $auto$ff.cc:262:slice$1210 ($sdff) from module top (D = $flatten\m1.$procmux$955_Y, Q = \m1.sum[2]).
Adding SRST signal on $flatten\m1.$procdff$1079 ($dff) from module top (D = $flatten\m1.$procmux$966_Y, Q = \m1.sum[1], rval = 0).
Adding EN signal on $auto$ff.cc:262:slice$1218 ($sdff) from module top (D = $flatten\m1.$procmux$966_Y, Q = \m1.sum[1]).
Adding SRST signal on $flatten\m1.$procdff$1078 ($dff) from module top (D = $flatten\m1.$procmux$977_Y, Q = \m1.sum[0], rval = 0).
Adding EN signal on $auto$ff.cc:262:slice$1226 ($sdff) from module top (D = $flatten\m1.$procmux$977_Y, Q = \m1.sum[0]).
Adding SRST signal on $flatten\m1.$procdff$1077 ($dff) from module top (D = $flatten\m1.$procmux$988_Y, Q = \m1.row_index, rval = 3'000).
Adding EN signal on $auto$ff.cc:262:slice$1234 ($sdff) from module top (D = $flatten\m1.$procmux$988_Y, Q = \m1.row_index).
Adding SRST signal on $flatten\m1.$procdff$1076 ($dff) from module top (D = $flatten\m1.$procmux$995_Y, Q = \m1.index, rval = 8'00000000).
Adding EN signal on $auto$ff.cc:262:slice$1238 ($sdff) from module top (D = $flatten\m1.$procmux$995_Y, Q = \m1.index).
Adding SRST signal on $flatten\m1.$procdff$1073 ($dff) from module top (D = $flatten\m1.$procmux$1032_Y, Q = \m1.D, rval = 0).
Adding EN signal on $auto$ff.cc:262:slice$1246 ($sdff) from module top (D = $flatten\m1.$procmux$1032_Y, Q = \m1.D).

3.13.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 12 unused cells and 22 unused wires.
<suppressed ~13 debug messages>

3.13.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~11 debug messages>

3.13.9. Rerunning OPT passes. (Maybe there is more to do..)

3.13.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~11 debug messages>

3.13.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
Performed a total of 0 changes.

3.13.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
<suppressed ~66 debug messages>
Removed a total of 22 cells.

3.13.13. Executing OPT_DFF pass (perform DFF optimizations).

3.13.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 0 unused cells and 22 unused wires.
<suppressed ~1 debug messages>

3.13.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.13.16. Rerunning OPT passes. (Maybe there is more to do..)

3.13.17. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~11 debug messages>

3.13.18. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
Performed a total of 0 changes.

3.13.19. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.13.20. Executing OPT_DFF pass (perform DFF optimizations).

3.13.21. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

3.13.22. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.13.23. Finished OPT passes. (There is nothing left to do.)

3.14. Executing WREDUCE pass (reducing word size of cells).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$587 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$588 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$589 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$590 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$591 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$592 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$593 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$594 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$595 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$596 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$597 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$598 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$599 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$600 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$601 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$602 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$603 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$604 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$605 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$606 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$607 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$608 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$609 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$610 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$611 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$612 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$613 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$614 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$615 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$616 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$617 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$618 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$619 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$620 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$621 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$622 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$623 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$624 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$625 (m1.A).
Removed top 26 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\A$matmul.v:35$626 (m1.A).
Removed top 28 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\B$matmul.v:38$627 (m1.B).
Removed top 28 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\B$matmul.v:38$628 (m1.B).
Removed top 28 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\B$matmul.v:38$629 (m1.B).
Removed top 28 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\B$matmul.v:38$630 (m1.B).
Removed top 28 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\B$matmul.v:38$631 (m1.B).
Removed top 28 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\B$matmul.v:38$632 (m1.B).
Removed top 28 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\B$matmul.v:38$633 (m1.B).
Removed top 28 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\B$matmul.v:38$634 (m1.B).
Removed top 28 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\B$matmul.v:38$635 (m1.B).
Removed top 28 address bits (of 32) from memory init port top.$flatten\m1.$meminit$\B$matmul.v:38$636 (m1.B).
Removed top 26 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\A$matmul.v:109$494 (m1.A).
Removed top 26 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\A$matmul.v:109$504 (m1.A).
Removed top 26 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\A$matmul.v:109$514 (m1.A).
Removed top 26 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\A$matmul.v:109$524 (m1.A).
Removed top 26 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\A$matmul.v:109$534 (m1.A).
Removed top 26 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\A$matmul.v:109$544 (m1.A).
Removed top 26 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\A$matmul.v:109$554 (m1.A).
Removed top 26 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\A$matmul.v:109$564 (m1.A).
Removed top 26 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\A$matmul.v:141$576 (m1.A).
Removed top 28 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\B$matmul.v:109$499 (m1.B).
Removed top 28 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\B$matmul.v:109$509 (m1.B).
Removed top 28 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\B$matmul.v:109$519 (m1.B).
Removed top 28 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\B$matmul.v:109$529 (m1.B).
Removed top 28 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\B$matmul.v:109$539 (m1.B).
Removed top 28 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\B$matmul.v:109$549 (m1.B).
Removed top 28 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\B$matmul.v:109$559 (m1.B).
Removed top 28 address bits (of 32) from memory read port top.$flatten\m1.$memrd$\B$matmul.v:109$569 (m1.B).
Removed top 4 address bits (of 8) from memory read port top.$flatten\m1.$memrd$\B$matmul.v:141$580 (m1.B).
Removed top 31 bits (of 32) from port B of cell top.$add$top.v:27$392 ($add).
Removed top 24 bits (of 32) from port Y of cell top.$add$top.v:27$392 ($add).
Removed cell top.$flatten\m1.$procmux$1035 ($mux).
Removed cell top.$flatten\m1.$procmux$998 ($mux).
Removed cell top.$flatten\m1.$procmux$980 ($mux).
Removed cell top.$flatten\m1.$procmux$969 ($mux).
Removed cell top.$flatten\m1.$procmux$958 ($mux).
Removed cell top.$flatten\m1.$procmux$947 ($mux).
Removed cell top.$flatten\m1.$procmux$936 ($mux).
Removed cell top.$flatten\m1.$procmux$925 ($mux).
Removed cell top.$flatten\m1.$procmux$914 ($mux).
Removed cell top.$flatten\m1.$procmux$903 ($mux).
Removed top 1 bits (of 3) from port B of cell top.$flatten\m1.$eq$matmul.v:161$586 ($eq).
Removed top 31 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:153$585 ($add).
Removed top 29 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:153$585 ($add).
Removed top 16 bits (of 32) from port Y of cell top.$flatten\m1.$mul$matmul.v:141$582 ($mul).
Removed top 4 bits (of 8) from port B of cell top.$flatten\m1.$add$matmul.v:141$581 ($add).
Removed top 4 bits (of 8) from port Y of cell top.$flatten\m1.$add$matmul.v:141$581 ($add).
Removed top 4 bits (of 8) from port A of cell top.$flatten\m1.$add$matmul.v:141$581 ($add).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:0$579 ($add).
Removed top 26 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:0$579 ($add).
Removed top 26 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:0$579 ($add).
Removed top 4 bits (of 8) from port B of cell top.$flatten\m1.$add$matmul.v:141$578 ($add).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:141$578 ($add).
Removed top 2 bits (of 8) from port A of cell top.$flatten\m1.$add$matmul.v:141$578 ($add).
Removed top 6 bits (of 8) from port B of cell top.$flatten\m1.$lt$matmul.v:140$575 ($lt).
Removed top 31 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:112$574 ($add).
Removed top 24 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:112$574 ($add).
Removed top 16 bits (of 32) from port Y of cell top.$flatten\m1.$mul$matmul.v:109$572 ($mul).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:0$568 ($add).
Removed top 26 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:0$568 ($add).
Removed top 26 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:0$568 ($add).
Removed top 29 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:109$567 ($add).
Removed top 21 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:109$567 ($add).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:109$567 ($add).
Removed top 5 bits (of 11) from port B of cell top.$flatten\m1.$add$matmul.v:109$567 ($add).
Removed top 16 bits (of 32) from port Y of cell top.$flatten\m1.$mul$matmul.v:109$562 ($mul).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:0$558 ($add).
Removed top 26 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:0$558 ($add).
Removed top 26 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:0$558 ($add).
Removed top 29 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:109$557 ($add).
Removed top 21 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:109$557 ($add).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:109$557 ($add).
Removed top 5 bits (of 11) from port B of cell top.$flatten\m1.$add$matmul.v:109$557 ($add).
Removed top 16 bits (of 32) from port Y of cell top.$flatten\m1.$mul$matmul.v:109$552 ($mul).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:0$548 ($add).
Removed top 26 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:0$548 ($add).
Removed top 26 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:0$548 ($add).
Removed top 29 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:109$547 ($add).
Removed top 21 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:109$547 ($add).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:109$547 ($add).
Removed top 5 bits (of 11) from port B of cell top.$flatten\m1.$add$matmul.v:109$547 ($add).
Removed top 16 bits (of 32) from port Y of cell top.$flatten\m1.$mul$matmul.v:109$542 ($mul).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:0$538 ($add).
Removed top 26 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:0$538 ($add).
Removed top 26 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:0$538 ($add).
Removed top 29 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:109$537 ($add).
Removed top 21 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:109$537 ($add).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:109$537 ($add).
Removed top 5 bits (of 11) from port B of cell top.$flatten\m1.$add$matmul.v:109$537 ($add).
Removed top 16 bits (of 32) from port Y of cell top.$flatten\m1.$mul$matmul.v:109$532 ($mul).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:0$528 ($add).
Removed top 26 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:0$528 ($add).
Removed top 26 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:0$528 ($add).
Removed top 30 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:109$527 ($add).
Removed top 21 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:109$527 ($add).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:109$527 ($add).
Removed top 5 bits (of 11) from port B of cell top.$flatten\m1.$add$matmul.v:109$527 ($add).
Removed top 16 bits (of 32) from port Y of cell top.$flatten\m1.$mul$matmul.v:109$522 ($mul).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:0$518 ($add).
Removed top 26 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:0$518 ($add).
Removed top 26 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:0$518 ($add).
Removed top 30 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:109$517 ($add).
Removed top 21 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:109$517 ($add).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:109$517 ($add).
Removed top 5 bits (of 11) from port B of cell top.$flatten\m1.$add$matmul.v:109$517 ($add).
Removed top 16 bits (of 32) from port Y of cell top.$flatten\m1.$mul$matmul.v:109$512 ($mul).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:0$508 ($add).
Removed top 26 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:0$508 ($add).
Removed top 26 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:0$508 ($add).
Removed top 31 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:109$507 ($add).
Removed top 21 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:109$507 ($add).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:109$507 ($add).
Removed top 5 bits (of 11) from port B of cell top.$flatten\m1.$add$matmul.v:109$507 ($add).
Removed top 16 bits (of 32) from port Y of cell top.$flatten\m1.$mul$matmul.v:109$502 ($mul).
Removed top 21 bits (of 32) from port B of cell top.$flatten\m1.$add$matmul.v:0$498 ($add).
Removed top 26 bits (of 32) from port Y of cell top.$flatten\m1.$add$matmul.v:0$498 ($add).
Removed top 26 bits (of 32) from port A of cell top.$flatten\m1.$add$matmul.v:0$498 ($add).
Removed top 5 bits (of 11) from port B of cell top.$flatten\m1.$add$matmul.v:0$498 ($add).
Removed top 28 bits (of 31) from port B of cell top.$flatten\m1.$mul$matmul.v:0$495 ($mul).
Removed top 26 bits (of 31) from port Y of cell top.$flatten\m1.$mul$matmul.v:0$495 ($mul).
Removed top 7 bits (of 8) from port B of cell top.$flatten\m1.$lt$matmul.v:106$493 ($lt).
Removed top 24 bits (of 32) from wire top.$add$top.v:27$392_Y.
Removed top 26 bits (of 32) from wire top.$flatten\m1.$add$matmul.v:0$498_Y.
Removed top 26 bits (of 32) from wire top.$flatten\m1.$add$matmul.v:0$508_Y.
Removed top 26 bits (of 32) from wire top.$flatten\m1.$add$matmul.v:0$518_Y.
Removed top 26 bits (of 32) from wire top.$flatten\m1.$add$matmul.v:0$528_Y.
Removed top 26 bits (of 32) from wire top.$flatten\m1.$add$matmul.v:0$538_Y.
Removed top 26 bits (of 32) from wire top.$flatten\m1.$add$matmul.v:0$548_Y.
Removed top 26 bits (of 32) from wire top.$flatten\m1.$add$matmul.v:0$558_Y.
Removed top 26 bits (of 32) from wire top.$flatten\m1.$add$matmul.v:0$568_Y.
Removed top 26 bits (of 32) from wire top.$flatten\m1.$add$matmul.v:0$579_Y.
Removed top 4 bits (of 8) from wire top.$flatten\m1.$add$matmul.v:141$581_Y.
Removed top 29 bits (of 32) from wire top.$flatten\m1.$add$matmul.v:153$585_Y.
Removed top 19 bits (of 32) from wire top.$flatten\m1.$mul$matmul.v:141$582_Y.
Removed top 3 bits (of 32) from wire top.$flatten\m1.$procmux$1035_Y.
Removed top 26 bits (of 32) from wire top.$flatten\m1.$procmux$900_Y.
Removed top 2 bits (of 32) from wire top.$flatten\m1.$procmux$911_Y.
Removed top 10 bits (of 32) from wire top.$flatten\m1.$procmux$922_Y.
Removed top 2 bits (of 32) from wire top.$flatten\m1.$procmux$933_Y.
Removed top 10 bits (of 32) from wire top.$flatten\m1.$procmux$944_Y.
Removed top 2 bits (of 32) from wire top.$flatten\m1.$procmux$955_Y.
Removed top 10 bits (of 32) from wire top.$flatten\m1.$procmux$966_Y.

3.15. Executing PEEPOPT pass (run peephole optimizers).

3.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 0 unused cells and 31 unused wires.
<suppressed ~1 debug messages>

3.17. Executing SHARE pass (SAT-based resource sharing).
Found 27 cells in module top that may be considered for resource sharing.
  Analyzing resource sharing options for $flatten\m1.$mul$matmul.v:141$582 ($mul):
    Found 1 activation_patterns using ctrl signal \m1.state [4].
    Found 8 candidates: $flatten\m1.$mul$matmul.v:109$572 $flatten\m1.$mul$matmul.v:109$562 $flatten\m1.$mul$matmul.v:109$552 $flatten\m1.$mul$matmul.v:109$542 $flatten\m1.$mul$matmul.v:109$532 $flatten\m1.$mul$matmul.v:109$522 $flatten\m1.$mul$matmul.v:109$512 $flatten\m1.$mul$matmul.v:109$502
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$572 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:141$582: \m1.state [4] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$572: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 12 variables, 39 clauses
      According to the SAT solver this pair of cells can be shared.
      Activation signal for $flatten\m1.$mul$matmul.v:141$582: $auto$share.cc:977:make_cell_activation_logic$1275
      New cell: $auto$share.cc:667:make_supercell$1282 ($mul)
  Analyzing resource sharing options for $auto$share.cc:667:make_supercell$1282 ($mul):
    Found 2 activation_patterns using ctrl signal \m1.state [4:3].
    Found 7 candidates: $flatten\m1.$mul$matmul.v:109$562 $flatten\m1.$mul$matmul.v:109$552 $flatten\m1.$mul$matmul.v:109$542 $flatten\m1.$mul$matmul.v:109$532 $flatten\m1.$mul$matmul.v:109$522 $flatten\m1.$mul$matmul.v:109$512 $flatten\m1.$mul$matmul.v:109$502
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$562 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$562: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$552 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$552: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$542 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$542: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$532 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$532: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$522 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$522: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$512 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$512: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$502 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:667:make_supercell$1282: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$502: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
  Analyzing resource sharing options for $flatten\m1.$mul$matmul.v:109$562 ($mul):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 6 candidates: $flatten\m1.$mul$matmul.v:109$552 $flatten\m1.$mul$matmul.v:109$542 $flatten\m1.$mul$matmul.v:109$532 $flatten\m1.$mul$matmul.v:109$522 $flatten\m1.$mul$matmul.v:109$512 $flatten\m1.$mul$matmul.v:109$502
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$552 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$562: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$552: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$542 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$562: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$542: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$532 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$562: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$532: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$522 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$562: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$522: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$512 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$562: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$512: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$502 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$562: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$502: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$mul$matmul.v:109$552 ($mul):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 5 candidates: $flatten\m1.$mul$matmul.v:109$542 $flatten\m1.$mul$matmul.v:109$532 $flatten\m1.$mul$matmul.v:109$522 $flatten\m1.$mul$matmul.v:109$512 $flatten\m1.$mul$matmul.v:109$502
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$542 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$552: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$542: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$532 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$552: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$532: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$522 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$552: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$522: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$512 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$552: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$512: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$502 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$552: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$502: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$mul$matmul.v:109$542 ($mul):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 4 candidates: $flatten\m1.$mul$matmul.v:109$532 $flatten\m1.$mul$matmul.v:109$522 $flatten\m1.$mul$matmul.v:109$512 $flatten\m1.$mul$matmul.v:109$502
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$532 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$542: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$532: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$522 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$542: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$522: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$512 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$542: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$512: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$502 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$542: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$502: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$mul$matmul.v:109$532 ($mul):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 3 candidates: $flatten\m1.$mul$matmul.v:109$522 $flatten\m1.$mul$matmul.v:109$512 $flatten\m1.$mul$matmul.v:109$502
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$522 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$532: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$522: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$512 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$532: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$512: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$502 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$532: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$502: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$mul$matmul.v:109$522 ($mul):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 2 candidates: $flatten\m1.$mul$matmul.v:109$512 $flatten\m1.$mul$matmul.v:109$502
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$512 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$522: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$512: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$502 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$522: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$502: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$mul$matmul.v:109$512 ($mul):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 1 candidates: $flatten\m1.$mul$matmul.v:109$502
    Analyzing resource sharing with $flatten\m1.$mul$matmul.v:109$502 ($mul):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$512: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$mul$matmul.v:109$502: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$mul$matmul.v:109$502 ($mul):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    No candidates found.
  Analyzing resource sharing options for $flatten\m1.$memrd$\B$matmul.v:141$580 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [4].
    Found 8 candidates: $flatten\m1.$memrd$\B$matmul.v:109$569 $flatten\m1.$memrd$\B$matmul.v:109$559 $flatten\m1.$memrd$\B$matmul.v:109$549 $flatten\m1.$memrd$\B$matmul.v:109$539 $flatten\m1.$memrd$\B$matmul.v:109$529 $flatten\m1.$memrd$\B$matmul.v:109$519 $flatten\m1.$memrd$\B$matmul.v:109$509 $flatten\m1.$memrd$\B$matmul.v:109$499
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$569 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:141$580: \m1.state [4] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$569: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 12 variables, 39 clauses
      According to the SAT solver this pair of cells can be shared.
      Activation signal for $flatten\m1.$memrd$\B$matmul.v:141$580: $auto$share.cc:977:make_cell_activation_logic$1285
      New cell: $auto$share.cc:711:make_supercell$1287 ($memrd)
  Analyzing resource sharing options for $auto$share.cc:711:make_supercell$1287 ($memrd):
    Found 2 activation_patterns using ctrl signal \m1.state [4:3].
    Found 7 candidates: $flatten\m1.$memrd$\B$matmul.v:109$559 $flatten\m1.$memrd$\B$matmul.v:109$549 $flatten\m1.$memrd$\B$matmul.v:109$539 $flatten\m1.$memrd$\B$matmul.v:109$529 $flatten\m1.$memrd$\B$matmul.v:109$519 $flatten\m1.$memrd$\B$matmul.v:109$509 $flatten\m1.$memrd$\B$matmul.v:109$499
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$559 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$559: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$549 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$549: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$539 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$539: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$529 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$529: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$519 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$519: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$509 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$509: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$499 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1287: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$499: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
  Analyzing resource sharing options for $flatten\m1.$memrd$\B$matmul.v:109$559 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 6 candidates: $flatten\m1.$memrd$\B$matmul.v:109$549 $flatten\m1.$memrd$\B$matmul.v:109$539 $flatten\m1.$memrd$\B$matmul.v:109$529 $flatten\m1.$memrd$\B$matmul.v:109$519 $flatten\m1.$memrd$\B$matmul.v:109$509 $flatten\m1.$memrd$\B$matmul.v:109$499
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$549 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$559: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$549: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$539 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$559: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$539: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$529 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$559: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$529: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$519 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$559: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$519: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$509 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$559: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$509: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$499 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$559: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$499: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\B$matmul.v:109$549 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 5 candidates: $flatten\m1.$memrd$\B$matmul.v:109$539 $flatten\m1.$memrd$\B$matmul.v:109$529 $flatten\m1.$memrd$\B$matmul.v:109$519 $flatten\m1.$memrd$\B$matmul.v:109$509 $flatten\m1.$memrd$\B$matmul.v:109$499
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$539 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$549: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$539: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$529 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$549: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$529: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$519 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$549: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$519: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$509 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$549: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$509: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$499 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$549: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$499: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\B$matmul.v:109$539 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 4 candidates: $flatten\m1.$memrd$\B$matmul.v:109$529 $flatten\m1.$memrd$\B$matmul.v:109$519 $flatten\m1.$memrd$\B$matmul.v:109$509 $flatten\m1.$memrd$\B$matmul.v:109$499
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$529 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$539: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$529: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$519 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$539: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$519: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$509 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$539: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$509: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$499 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$539: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$499: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\B$matmul.v:109$529 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 3 candidates: $flatten\m1.$memrd$\B$matmul.v:109$519 $flatten\m1.$memrd$\B$matmul.v:109$509 $flatten\m1.$memrd$\B$matmul.v:109$499
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$519 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$529: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$519: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$509 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$529: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$509: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$499 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$529: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$499: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\B$matmul.v:109$519 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 2 candidates: $flatten\m1.$memrd$\B$matmul.v:109$509 $flatten\m1.$memrd$\B$matmul.v:109$499
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$509 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$519: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$509: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$499 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$519: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$499: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\B$matmul.v:109$509 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 1 candidates: $flatten\m1.$memrd$\B$matmul.v:109$499
    Analyzing resource sharing with $flatten\m1.$memrd$\B$matmul.v:109$499 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$509: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\B$matmul.v:109$499: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\B$matmul.v:109$499 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    No candidates found.
  Analyzing resource sharing options for $flatten\m1.$memrd$\A$matmul.v:141$576 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [4].
    Found 8 candidates: $flatten\m1.$memrd$\A$matmul.v:109$564 $flatten\m1.$memrd$\A$matmul.v:109$554 $flatten\m1.$memrd$\A$matmul.v:109$544 $flatten\m1.$memrd$\A$matmul.v:109$534 $flatten\m1.$memrd$\A$matmul.v:109$524 $flatten\m1.$memrd$\A$matmul.v:109$514 $flatten\m1.$memrd$\A$matmul.v:109$504 $flatten\m1.$memrd$\A$matmul.v:109$494
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$564 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:141$576: \m1.state [4] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$564: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 12 variables, 39 clauses
      According to the SAT solver this pair of cells can be shared.
      Activation signal for $flatten\m1.$memrd$\A$matmul.v:141$576: $auto$share.cc:977:make_cell_activation_logic$1291
      New cell: $auto$share.cc:711:make_supercell$1293 ($memrd)
  Analyzing resource sharing options for $auto$share.cc:711:make_supercell$1293 ($memrd):
    Found 2 activation_patterns using ctrl signal \m1.state [4:3].
    Found 7 candidates: $flatten\m1.$memrd$\A$matmul.v:109$554 $flatten\m1.$memrd$\A$matmul.v:109$544 $flatten\m1.$memrd$\A$matmul.v:109$534 $flatten\m1.$memrd$\A$matmul.v:109$524 $flatten\m1.$memrd$\A$matmul.v:109$514 $flatten\m1.$memrd$\A$matmul.v:109$504 $flatten\m1.$memrd$\A$matmul.v:109$494
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$554 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$554: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$544 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$544: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$534 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$534: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$524 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$524: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$514 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$514: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$504 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$504: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$494 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [4] = 1'1
      Activation pattern for cell $auto$share.cc:711:make_supercell$1293: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$494: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 15 variables, 48 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [4:3] = 2'01
  Analyzing resource sharing options for $flatten\m1.$memrd$\A$matmul.v:109$554 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 6 candidates: $flatten\m1.$memrd$\A$matmul.v:109$544 $flatten\m1.$memrd$\A$matmul.v:109$534 $flatten\m1.$memrd$\A$matmul.v:109$524 $flatten\m1.$memrd$\A$matmul.v:109$514 $flatten\m1.$memrd$\A$matmul.v:109$504 $flatten\m1.$memrd$\A$matmul.v:109$494
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$544 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$554: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$544: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$534 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$554: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$534: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$524 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$554: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$524: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$514 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$554: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$514: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$504 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$554: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$504: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$494 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$554: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$494: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\A$matmul.v:109$544 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 5 candidates: $flatten\m1.$memrd$\A$matmul.v:109$534 $flatten\m1.$memrd$\A$matmul.v:109$524 $flatten\m1.$memrd$\A$matmul.v:109$514 $flatten\m1.$memrd$\A$matmul.v:109$504 $flatten\m1.$memrd$\A$matmul.v:109$494
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$534 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$544: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$534: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$524 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$544: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$524: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$514 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$544: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$514: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$504 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$544: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$504: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$494 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$544: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$494: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\A$matmul.v:109$534 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 4 candidates: $flatten\m1.$memrd$\A$matmul.v:109$524 $flatten\m1.$memrd$\A$matmul.v:109$514 $flatten\m1.$memrd$\A$matmul.v:109$504 $flatten\m1.$memrd$\A$matmul.v:109$494
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$524 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$534: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$524: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$514 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$534: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$514: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$504 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$534: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$504: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$494 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$534: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$494: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\A$matmul.v:109$524 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 3 candidates: $flatten\m1.$memrd$\A$matmul.v:109$514 $flatten\m1.$memrd$\A$matmul.v:109$504 $flatten\m1.$memrd$\A$matmul.v:109$494
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$514 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$524: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$514: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$504 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$524: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$504: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$494 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$524: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$494: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\A$matmul.v:109$514 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 2 candidates: $flatten\m1.$memrd$\A$matmul.v:109$504 $flatten\m1.$memrd$\A$matmul.v:109$494
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$504 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$514: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$504: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$494 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$514: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$494: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\A$matmul.v:109$504 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    Found 1 candidates: $flatten\m1.$memrd$\A$matmul.v:109$494
    Analyzing resource sharing with $flatten\m1.$memrd$\A$matmul.v:109$494 ($memrd):
      Found 1 activation_patterns using ctrl signal \m1.state [3].
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$504: \m1.state [3] = 1'1
      Activation pattern for cell $flatten\m1.$memrd$\A$matmul.v:109$494: \m1.state [3] = 1'1
      Size of SAT problem: 0 cells, 9 variables, 29 clauses
      According to the SAT solver this pair of cells can not be shared.
      Model from SAT solver: \m1.state [3] = 1'1
  Analyzing resource sharing options for $flatten\m1.$memrd$\A$matmul.v:109$494 ($memrd):
    Found 1 activation_patterns using ctrl signal \m1.state [3].
    No candidates found.
Removing 6 cells in module top:
  Removing cell $flatten\m1.$memrd$\A$matmul.v:109$564 ($memrd).
  Removing cell $flatten\m1.$memrd$\A$matmul.v:141$576 ($memrd).
  Removing cell $flatten\m1.$memrd$\B$matmul.v:109$569 ($memrd).
  Removing cell $flatten\m1.$memrd$\B$matmul.v:141$580 ($memrd).
  Removing cell $flatten\m1.$mul$matmul.v:109$572 ($mul).
  Removing cell $flatten\m1.$mul$matmul.v:141$582 ($mul).

3.18. Executing TECHMAP pass (map to technology primitives).

3.18.1. Executing Verilog-2005 frontend: /home/mahesh/oss-cad-suite/lib/../share/yosys/cmp2lut.v
Parsing Verilog input from `/home/mahesh/oss-cad-suite/lib/../share/yosys/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

3.18.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~62 debug messages>

3.19. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~3 debug messages>

3.20. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 0 unused cells and 7 unused wires.
<suppressed ~5 debug messages>

3.21. Executing MEMORY_DFF pass (merging $dff cells to $memrd).
Checking read port `\m1.A'[0] in module `\top': no output FF found.
Checking read port `\m1.A'[1] in module `\top': no output FF found.
Checking read port `\m1.A'[2] in module `\top': no output FF found.
Checking read port `\m1.A'[3] in module `\top': no output FF found.
Checking read port `\m1.A'[4] in module `\top': no output FF found.
Checking read port `\m1.A'[5] in module `\top': no output FF found.
Checking read port `\m1.A'[6] in module `\top': no output FF found.
Checking read port `\m1.A'[7] in module `\top': no output FF found.
Checking read port `\m1.B'[0] in module `\top': no output FF found.
Checking read port `\m1.B'[1] in module `\top': no output FF found.
Checking read port `\m1.B'[2] in module `\top': no output FF found.
Checking read port `\m1.B'[3] in module `\top': no output FF found.
Checking read port `\m1.B'[4] in module `\top': no output FF found.
Checking read port `\m1.B'[5] in module `\top': no output FF found.
Checking read port `\m1.B'[6] in module `\top': no output FF found.
Checking read port `\m1.B'[7] in module `\top': no output FF found.
Checking read port address `\m1.A'[0] in module `\top': no address FF found.
Checking read port address `\m1.A'[1] in module `\top': no address FF found.
Checking read port address `\m1.A'[2] in module `\top': no address FF found.
Checking read port address `\m1.A'[3] in module `\top': no address FF found.
Checking read port address `\m1.A'[4] in module `\top': no address FF found.
Checking read port address `\m1.A'[5] in module `\top': no address FF found.
Checking read port address `\m1.A'[6] in module `\top': no address FF found.
Checking read port address `\m1.A'[7] in module `\top': no address FF found.
Checking read port address `\m1.B'[0] in module `\top': no address FF found.
Checking read port address `\m1.B'[1] in module `\top': no address FF found.
Checking read port address `\m1.B'[2] in module `\top': no address FF found.
Checking read port address `\m1.B'[3] in module `\top': no address FF found.
Checking read port address `\m1.B'[4] in module `\top': no address FF found.
Checking read port address `\m1.B'[5] in module `\top': no address FF found.
Checking read port address `\m1.B'[6] in module `\top': merged address FF to cell.
Checking read port address `\m1.B'[7] in module `\top': no address FF found.

3.22. Executing WREDUCE pass (reducing word size of cells).

3.23. Executing TECHMAP pass (map to technology primitives).

3.23.1. Executing Verilog-2005 frontend: /home/mahesh/oss-cad-suite/lib/../share/yosys/mul2dsp.v
Parsing Verilog input from `/home/mahesh/oss-cad-suite/lib/../share/yosys/mul2dsp.v' to AST representation.
Generating RTLIL representation for module `\_80_mul'.
Generating RTLIL representation for module `\_90_soft_mul'.
Successfully finished Verilog frontend.

3.23.2. Executing Verilog-2005 frontend: /home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/dsp_map.v
Parsing Verilog input from `/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/dsp_map.v' to AST representation.
Generating RTLIL representation for module `\$__MUL16X16'.
Successfully finished Verilog frontend.

3.23.3. Continuing TECHMAP pass.
Using template $paramod$a401ee114c0c9b2ce72be77ae746d4193a701a25\_80_mul for cells of type $mul.
Using template $paramod$802e88a71000076a6605dbafc5dcc4bc0f48184e\_90_soft_mul for cells of type $mul.
Using template $paramod$e7891eaf1790b1f744f5cd70dfa4eae29c2668f6\$__MUL16X16 for cells of type $__MUL16X16.
No more expansions possible.
<suppressed ~153 debug messages>

3.24. Executing OPT_EXPR pass (perform const folding).

3.25. Executing WREDUCE pass (reducing word size of cells).

3.26. Executing ICE40_DSP pass (map multipliers).
Checking top.$flatten\m1.$mul$matmul.v:109$502 for iCE40 DSP inference.
Checking top.$flatten\m1.$mul$matmul.v:109$512 for iCE40 DSP inference.
Checking top.$flatten\m1.$mul$matmul.v:109$522 for iCE40 DSP inference.
Checking top.$flatten\m1.$mul$matmul.v:109$532 for iCE40 DSP inference.
Checking top.$flatten\m1.$mul$matmul.v:109$542 for iCE40 DSP inference.
Checking top.$flatten\m1.$mul$matmul.v:109$552 for iCE40 DSP inference.
Checking top.$flatten\m1.$mul$matmul.v:109$562 for iCE40 DSP inference.
Checking top.$auto$share.cc:667:make_supercell$1282 for iCE40 DSP inference.
<suppressed ~80 debug messages>

3.27. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module top:
  creating $macc model for $add$top.v:27$392 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:0$498 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:0$508 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:0$518 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:0$528 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:0$538 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:0$548 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:0$558 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:0$568 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:0$579 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$503 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$507 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$513 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$517 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$523 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$527 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$533 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$537 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$543 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$547 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$553 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$557 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$563 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$567 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:109$573 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:112$574 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:141$578 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:141$581 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:141$583 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:153$585 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:65$459 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:66$460 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:67$461 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:68$462 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:69$463 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:70$464 ($add).
  creating $macc model for $flatten\m1.$add$matmul.v:71$465 ($add).
  creating $macc model for $flatten\m1.$mul$matmul.v:0$495 ($mul).
  merging $macc model for $flatten\m1.$add$matmul.v:69$463 into $flatten\m1.$add$matmul.v:71$465.
  merging $macc model for $flatten\m1.$add$matmul.v:65$459 into $flatten\m1.$add$matmul.v:71$465.
  merging $macc model for $flatten\m1.$add$matmul.v:70$464 into $flatten\m1.$add$matmul.v:71$465.
  merging $macc model for $flatten\m1.$add$matmul.v:67$461 into $flatten\m1.$add$matmul.v:71$465.
  merging $macc model for $flatten\m1.$add$matmul.v:66$460 into $flatten\m1.$add$matmul.v:71$465.
  merging $macc model for $flatten\m1.$add$matmul.v:68$462 into $flatten\m1.$add$matmul.v:71$465.
  merging $macc model for $flatten\m1.$add$matmul.v:141$578 into $flatten\m1.$add$matmul.v:0$579.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:153$585.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:141$583.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:141$581.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:112$574.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$573.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$567.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$563.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$557.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$553.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$547.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$543.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$537.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$533.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$527.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$523.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$517.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$513.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$507.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:109$503.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:0$568.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:0$558.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:0$548.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:0$538.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:0$528.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:0$518.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:0$508.
  creating $alu model for $macc $flatten\m1.$add$matmul.v:0$498.
  creating $alu model for $macc $add$top.v:27$392.
  creating $macc cell for $flatten\m1.$mul$matmul.v:0$495: $auto$alumacc.cc:365:replace_macc$1383
  creating $macc cell for $flatten\m1.$add$matmul.v:0$579: $auto$alumacc.cc:365:replace_macc$1384
  creating $macc cell for $flatten\m1.$add$matmul.v:71$465: $auto$alumacc.cc:365:replace_macc$1385
  creating $alu model for $flatten\m1.$lt$matmul.v:106$493 ($lt): new $alu
  creating $alu model for $flatten\m1.$lt$matmul.v:140$575 ($lt): new $alu
  creating $alu cell for $flatten\m1.$lt$matmul.v:140$575: $auto$alumacc.cc:485:replace_alu$1388
  creating $alu cell for $add$top.v:27$392: $auto$alumacc.cc:485:replace_alu$1399
  creating $alu cell for $flatten\m1.$add$matmul.v:0$498: $auto$alumacc.cc:485:replace_alu$1402
  creating $alu cell for $flatten\m1.$add$matmul.v:0$508: $auto$alumacc.cc:485:replace_alu$1405
  creating $alu cell for $flatten\m1.$add$matmul.v:0$518: $auto$alumacc.cc:485:replace_alu$1408
  creating $alu cell for $flatten\m1.$add$matmul.v:0$528: $auto$alumacc.cc:485:replace_alu$1411
  creating $alu cell for $flatten\m1.$add$matmul.v:0$538: $auto$alumacc.cc:485:replace_alu$1414
  creating $alu cell for $flatten\m1.$add$matmul.v:0$548: $auto$alumacc.cc:485:replace_alu$1417
  creating $alu cell for $flatten\m1.$add$matmul.v:0$558: $auto$alumacc.cc:485:replace_alu$1420
  creating $alu cell for $flatten\m1.$add$matmul.v:0$568: $auto$alumacc.cc:485:replace_alu$1423
  creating $alu cell for $flatten\m1.$add$matmul.v:109$503: $auto$alumacc.cc:485:replace_alu$1426
  creating $alu cell for $flatten\m1.$add$matmul.v:109$507: $auto$alumacc.cc:485:replace_alu$1429
  creating $alu cell for $flatten\m1.$add$matmul.v:109$513: $auto$alumacc.cc:485:replace_alu$1432
  creating $alu cell for $flatten\m1.$add$matmul.v:109$517: $auto$alumacc.cc:485:replace_alu$1435
  creating $alu cell for $flatten\m1.$add$matmul.v:109$523: $auto$alumacc.cc:485:replace_alu$1438
  creating $alu cell for $flatten\m1.$add$matmul.v:109$527: $auto$alumacc.cc:485:replace_alu$1441
  creating $alu cell for $flatten\m1.$add$matmul.v:109$533: $auto$alumacc.cc:485:replace_alu$1444
  creating $alu cell for $flatten\m1.$add$matmul.v:109$537: $auto$alumacc.cc:485:replace_alu$1447
  creating $alu cell for $flatten\m1.$add$matmul.v:109$543: $auto$alumacc.cc:485:replace_alu$1450
  creating $alu cell for $flatten\m1.$add$matmul.v:109$547: $auto$alumacc.cc:485:replace_alu$1453
  creating $alu cell for $flatten\m1.$add$matmul.v:109$553: $auto$alumacc.cc:485:replace_alu$1456
  creating $alu cell for $flatten\m1.$add$matmul.v:109$557: $auto$alumacc.cc:485:replace_alu$1459
  creating $alu cell for $flatten\m1.$add$matmul.v:109$563: $auto$alumacc.cc:485:replace_alu$1462
  creating $alu cell for $flatten\m1.$add$matmul.v:109$567: $auto$alumacc.cc:485:replace_alu$1465
  creating $alu cell for $flatten\m1.$add$matmul.v:109$573: $auto$alumacc.cc:485:replace_alu$1468
  creating $alu cell for $flatten\m1.$lt$matmul.v:106$493: $auto$alumacc.cc:485:replace_alu$1471
  creating $alu cell for $flatten\m1.$add$matmul.v:112$574: $auto$alumacc.cc:485:replace_alu$1482
  creating $alu cell for $flatten\m1.$add$matmul.v:141$581: $auto$alumacc.cc:485:replace_alu$1485
  creating $alu cell for $flatten\m1.$add$matmul.v:141$583: $auto$alumacc.cc:485:replace_alu$1488
  creating $alu cell for $flatten\m1.$add$matmul.v:153$585: $auto$alumacc.cc:485:replace_alu$1491
  created 30 $alu and 3 $macc cells.

3.28. Executing OPT pass (performing simple optimizations).

3.28.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~3 debug messages>

3.28.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.28.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~14 debug messages>

3.28.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
Performed a total of 0 changes.

3.28.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.28.6. Executing OPT_DFF pass (perform DFF optimizations).

3.28.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 7 unused cells and 86 unused wires.
<suppressed ~14 debug messages>

3.28.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.28.9. Rerunning OPT passes. (Maybe there is more to do..)

3.28.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~14 debug messages>

3.28.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
Performed a total of 0 changes.

3.28.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.28.13. Executing OPT_DFF pass (perform DFF optimizations).

3.28.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

3.28.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.28.16. Finished OPT passes. (There is nothing left to do.)

3.29. Executing MEMORY pass.

3.29.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

3.29.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

3.29.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

3.29.4. Executing MEMORY_DFF pass (merging $dff cells to $memrd).
Checking read port `\m1.A'[0] in module `\top': no output FF found.
Checking read port `\m1.A'[1] in module `\top': no output FF found.
Checking read port `\m1.A'[2] in module `\top': no output FF found.
Checking read port `\m1.A'[3] in module `\top': no output FF found.
Checking read port `\m1.A'[4] in module `\top': no output FF found.
Checking read port `\m1.A'[5] in module `\top': no output FF found.
Checking read port `\m1.A'[6] in module `\top': no output FF found.
Checking read port `\m1.A'[7] in module `\top': no output FF found.
Checking read port `\m1.B'[0] in module `\top': no output FF found.
Checking read port `\m1.B'[1] in module `\top': no output FF found.
Checking read port `\m1.B'[2] in module `\top': no output FF found.
Checking read port `\m1.B'[3] in module `\top': no output FF found.
Checking read port `\m1.B'[4] in module `\top': no output FF found.
Checking read port `\m1.B'[5] in module `\top': no output FF found.
Checking read port `\m1.B'[7] in module `\top': no output FF found.
Checking read port address `\m1.A'[0] in module `\top': no address FF found.
Checking read port address `\m1.A'[1] in module `\top': no address FF found.
Checking read port address `\m1.A'[2] in module `\top': no address FF found.
Checking read port address `\m1.A'[3] in module `\top': no address FF found.
Checking read port address `\m1.A'[4] in module `\top': no address FF found.
Checking read port address `\m1.A'[5] in module `\top': no address FF found.
Checking read port address `\m1.A'[6] in module `\top': no address FF found.
Checking read port address `\m1.A'[7] in module `\top': no address FF found.
Checking read port address `\m1.B'[0] in module `\top': no address FF found.
Checking read port address `\m1.B'[1] in module `\top': no address FF found.
Checking read port address `\m1.B'[2] in module `\top': no address FF found.
Checking read port address `\m1.B'[3] in module `\top': no address FF found.
Checking read port address `\m1.B'[4] in module `\top': no address FF found.
Checking read port address `\m1.B'[5] in module `\top': no address FF found.
Checking read port address `\m1.B'[7] in module `\top': no address FF found.

3.29.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

3.29.6. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).
Consolidating read ports of memory top.m1.A by address:
Consolidating read ports of memory top.m1.B by address:

3.29.7. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

3.29.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

3.29.9. Executing MEMORY_COLLECT pass (generating $mem cells).

3.30. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

3.31. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).
Processing top.m1.A:
  Properties: ports=8 bits=320 rports=8 wports=0 dbits=8 abits=6 words=40
  Checking rule #1 for bram type $__ICE40_RAM4K_M0 (variant 1):
    Bram geometry: abits=8 dbits=16 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M0: awaste=216 dwaste=8 bwaste=3776 waste=3776 efficiency=7
    Rule #1 for bram type $__ICE40_RAM4K_M0 (variant 1) accepted.
    Mapping to bram type $__ICE40_RAM4K_M0 (variant 1):
      Read port #0 is in clock domain !~async~.
        Bram port A1.1 has incompatible clock type.
        Failed to map read port #0.
    Mapping to bram type $__ICE40_RAM4K_M0 failed.
  Checking rule #2 for bram type $__ICE40_RAM4K_M0 (variant 1):
    Bram geometry: abits=8 dbits=16 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
  Checking rule #3 for bram type $__ICE40_RAM4K_M0 (variant 1):
    Bram geometry: abits=8 dbits=16 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
  Checking rule #4 for bram type $__ICE40_RAM4K_M123 (variant 1):
    Bram geometry: abits=9 dbits=8 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=472 dwaste=0 bwaste=3776 waste=3776 efficiency=7
    Rule #4 for bram type $__ICE40_RAM4K_M123 (variant 1) accepted.
    Mapping to bram type $__ICE40_RAM4K_M123 (variant 1):
      Read port #0 is in clock domain !~async~.
        Bram port A1.1 has incompatible clock type.
        Failed to map read port #0.
    Mapping to bram type $__ICE40_RAM4K_M123 failed.
  Checking rule #4 for bram type $__ICE40_RAM4K_M123 (variant 2):
    Bram geometry: abits=10 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=984 dwaste=0 bwaste=3936 waste=3936 efficiency=3
    Rule #4 for bram type $__ICE40_RAM4K_M123 (variant 2) accepted.
    Mapping to bram type $__ICE40_RAM4K_M123 (variant 2):
      Read port #0 is in clock domain !~async~.
        Bram port A1.1 has incompatible clock type.
        Failed to map read port #0.
    Mapping to bram type $__ICE40_RAM4K_M123 failed.
  Checking rule #4 for bram type $__ICE40_RAM4K_M123 (variant 3):
    Bram geometry: abits=11 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=2008 dwaste=0 bwaste=4016 waste=4016 efficiency=1
    Rule #4 for bram type $__ICE40_RAM4K_M123 (variant 3) rejected: requirement 'min efficiency 2' not met.
  Checking rule #5 for bram type $__ICE40_RAM4K_M123 (variant 1):
    Bram geometry: abits=9 dbits=8 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
  Checking rule #5 for bram type $__ICE40_RAM4K_M123 (variant 2):
    Bram geometry: abits=10 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
  Checking rule #5 for bram type $__ICE40_RAM4K_M123 (variant 3):
    Bram geometry: abits=11 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=2008 dwaste=0 bwaste=4016 waste=4016 efficiency=1
    Rule #5 for bram type $__ICE40_RAM4K_M123 (variant 3) rejected: requirement 'min wports 1' not met.
  Checking rule #6 for bram type $__ICE40_RAM4K_M123 (variant 1):
    Bram geometry: abits=9 dbits=8 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
  Checking rule #6 for bram type $__ICE40_RAM4K_M123 (variant 2):
    Bram geometry: abits=10 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
  Checking rule #6 for bram type $__ICE40_RAM4K_M123 (variant 3):
    Bram geometry: abits=11 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=2008 dwaste=0 bwaste=4016 waste=4016 efficiency=1
    Rule for bram type $__ICE40_RAM4K_M123 (variant 3) rejected: requirement 'attribute syn_romstyle="ebr" ...' not met.
  No acceptable bram resources found.
Processing top.m1.B:
  Properties: ports=8 bits=80 rports=8 wports=0 dbits=8 abits=4 words=10
  Checking rule #1 for bram type $__ICE40_RAM4K_M0 (variant 1):
    Bram geometry: abits=8 dbits=16 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M0: awaste=246 dwaste=8 bwaste=4016 waste=4016 efficiency=1
    Rule #1 for bram type $__ICE40_RAM4K_M0 (variant 1) rejected: requirement 'min efficiency 2' not met.
  Checking rule #2 for bram type $__ICE40_RAM4K_M0 (variant 1):
    Bram geometry: abits=8 dbits=16 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M0: awaste=246 dwaste=8 bwaste=4016 waste=4016 efficiency=1
    Rule #2 for bram type $__ICE40_RAM4K_M0 (variant 1) rejected: requirement 'min wports 1' not met.
  Checking rule #3 for bram type $__ICE40_RAM4K_M0 (variant 1):
    Bram geometry: abits=8 dbits=16 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M0: awaste=246 dwaste=8 bwaste=4016 waste=4016 efficiency=1
    Rule for bram type $__ICE40_RAM4K_M0 (variant 1) rejected: requirement 'attribute syn_romstyle="ebr" ...' not met.
  Checking rule #4 for bram type $__ICE40_RAM4K_M123 (variant 1):
    Bram geometry: abits=9 dbits=8 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=502 dwaste=0 bwaste=4016 waste=4016 efficiency=1
    Rule #4 for bram type $__ICE40_RAM4K_M123 (variant 1) rejected: requirement 'min efficiency 2' not met.
  Checking rule #4 for bram type $__ICE40_RAM4K_M123 (variant 2):
    Bram geometry: abits=10 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=1014 dwaste=0 bwaste=4056 waste=4056 efficiency=0
    Rule #4 for bram type $__ICE40_RAM4K_M123 (variant 2) rejected: requirement 'min efficiency 2' not met.
  Checking rule #4 for bram type $__ICE40_RAM4K_M123 (variant 3):
    Bram geometry: abits=11 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=2038 dwaste=0 bwaste=4076 waste=4076 efficiency=0
    Rule #4 for bram type $__ICE40_RAM4K_M123 (variant 3) rejected: requirement 'min efficiency 2' not met.
  Checking rule #5 for bram type $__ICE40_RAM4K_M123 (variant 1):
    Bram geometry: abits=9 dbits=8 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=502 dwaste=0 bwaste=4016 waste=4016 efficiency=1
    Rule #5 for bram type $__ICE40_RAM4K_M123 (variant 1) rejected: requirement 'min wports 1' not met.
  Checking rule #5 for bram type $__ICE40_RAM4K_M123 (variant 2):
    Bram geometry: abits=10 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=1014 dwaste=0 bwaste=4056 waste=4056 efficiency=0
    Rule #5 for bram type $__ICE40_RAM4K_M123 (variant 2) rejected: requirement 'min wports 1' not met.
  Checking rule #5 for bram type $__ICE40_RAM4K_M123 (variant 3):
    Bram geometry: abits=11 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=2038 dwaste=0 bwaste=4076 waste=4076 efficiency=0
    Rule #5 for bram type $__ICE40_RAM4K_M123 (variant 3) rejected: requirement 'min wports 1' not met.
  Checking rule #6 for bram type $__ICE40_RAM4K_M123 (variant 1):
    Bram geometry: abits=9 dbits=8 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=502 dwaste=0 bwaste=4016 waste=4016 efficiency=1
    Rule for bram type $__ICE40_RAM4K_M123 (variant 1) rejected: requirement 'attribute syn_romstyle="ebr" ...' not met.
  Checking rule #6 for bram type $__ICE40_RAM4K_M123 (variant 2):
    Bram geometry: abits=10 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=1014 dwaste=0 bwaste=4056 waste=4056 efficiency=0
    Rule for bram type $__ICE40_RAM4K_M123 (variant 2) rejected: requirement 'attribute syn_romstyle="ebr" ...' not met.
  Checking rule #6 for bram type $__ICE40_RAM4K_M123 (variant 3):
    Bram geometry: abits=11 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__ICE40_RAM4K_M123: awaste=2038 dwaste=0 bwaste=4076 waste=4076 efficiency=0
    Rule for bram type $__ICE40_RAM4K_M123 (variant 3) rejected: requirement 'attribute syn_romstyle="ebr" ...' not met.
  No acceptable bram resources found.

3.32. Executing TECHMAP pass (map to technology primitives).

3.32.1. Executing Verilog-2005 frontend: /home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/brams_map.v
Parsing Verilog input from `/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/brams_map.v' to AST representation.
Generating RTLIL representation for module `\$__ICE40_RAM4K'.
Generating RTLIL representation for module `\$__ICE40_RAM4K_M0'.
Generating RTLIL representation for module `\$__ICE40_RAM4K_M123'.
Successfully finished Verilog frontend.

3.32.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~5 debug messages>

3.33. Executing ICE40_BRAMINIT pass.

3.34. Executing OPT pass (performing simple optimizations).

3.34.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~60 debug messages>

3.34.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
<suppressed ~29 debug messages>
Removed a total of 7 cells.

3.34.3. Executing OPT_DFF pass (perform DFF optimizations).

3.34.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 1 unused cells and 38 unused wires.
<suppressed ~3 debug messages>

3.34.5. Finished fast OPT passes.

3.35. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).
Mapping memory \m1.A in module \top:
  created 40 $dff cells and 0 static cells of width 8.
  read interface: 0 $dff and 504 $mux cells.
  write interface: 0 write mux blocks.
Mapping memory \m1.B in module \top:
  created 10 $dff cells and 0 static cells of width 8.
Extracted data FF from read port 6 of top.m1.B: $\m1.B$rdreg[6]
  read interface: 1 $dff and 120 $mux cells.
  write interface: 0 write mux blocks.

3.36. Executing OPT pass (performing simple optimizations).

3.36.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~706 debug messages>

3.36.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.36.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~30 debug messages>

3.36.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
    Consolidated identical input bits for $mux cell $auto$ff.cc:499:unmap_ce$1329:
      Old ports: A={ \m1.index [0] 3'000 }, B={ $flatten\m1.$procmux$995_Y [0] 3'000 }, Y=$auto$rtlil.cc:2459:Mux$1330
      New ports: A=\m1.index [0], B=$flatten\m1.$procmux$995_Y [0], Y=$auto$rtlil.cc:2459:Mux$1330 [3]
      New connections: $auto$rtlil.cc:2459:Mux$1330 [2:0] = 3'000
  Optimizing cells in module \top.
    Consolidated identical input bits for $mux cell $auto$ff.cc:521:unmap_srst$1331:
      Old ports: A=4'0000, B=$auto$rtlil.cc:2459:Mux$1330, Y=$auto$rtlil.cc:2459:Mux$1332
      New ports: A=1'0, B=$auto$rtlil.cc:2459:Mux$1330 [3], Y=$auto$rtlil.cc:2459:Mux$1332 [3]
      New connections: $auto$rtlil.cc:2459:Mux$1332 [2:0] = 3'000
  Optimizing cells in module \top.
Performed a total of 2 changes.

3.36.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
<suppressed ~60 debug messages>
Removed a total of 20 cells.

3.36.6. Executing OPT_DFF pass (perform DFF optimizations).
Handling const CLK on $memory\m1.A[0]$1540 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[1]$1542 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[2]$1544 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[3]$1546 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[4]$1548 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[5]$1550 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[6]$1552 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[7]$1554 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[8]$1556 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[9]$1558 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[10]$1560 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[11]$1562 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[12]$1564 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[13]$1566 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[14]$1568 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[15]$1570 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[16]$1572 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[17]$1574 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[18]$1576 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[19]$1578 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[20]$1580 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[21]$1582 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[22]$1584 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[23]$1586 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[24]$1588 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[25]$1590 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[26]$1592 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[27]$1594 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[28]$1596 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[29]$1598 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[30]$1600 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[31]$1602 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[32]$1604 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[33]$1606 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[34]$1608 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[35]$1610 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[36]$1612 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[37]$1614 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[38]$1616 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.A[39]$1618 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.B[8]$3148 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.B[4]$3140 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.B[1]$3134 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.B[2]$3136 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.B[9]$3150 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.B[0]$3132 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.B[3]$3138 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.B[6]$3144 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.B[7]$3146 ($dff) from module top (removing D path).
Handling const CLK on $memory\m1.B[5]$3142 ($dff) from module top (removing D path).

3.36.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 0 unused cells and 1118 unused wires.
<suppressed ~1 debug messages>

3.36.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~10 debug messages>

3.36.9. Rerunning OPT passes. (Maybe there is more to do..)

3.36.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~50 debug messages>

3.36.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][4][0]$1665:
      Old ports: A=8'00000000, B=8'00000010, Y=$memory\m1.A$rdmux[0][3][0]$a$1642
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[0][3][0]$a$1642 [1]
      New connections: { $memory\m1.A$rdmux[0][3][0]$a$1642 [7:2] $memory\m1.A$rdmux[0][3][0]$a$1642 [0] } = 7'0000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][4][1]$1668:
      Old ports: A=8'00000100, B=8'00000110, Y=$memory\m1.A$rdmux[0][3][0]$b$1643
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[0][3][0]$b$1643 [1]
      New connections: { $memory\m1.A$rdmux[0][3][0]$b$1643 [7:2] $memory\m1.A$rdmux[0][3][0]$b$1643 [0] } = 7'0000010
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][4][2]$1671:
      Old ports: A=8'00001000, B=8'00000001, Y=$memory\m1.A$rdmux[0][3][1]$a$1645
      New ports: A=2'10, B=2'01, Y={ $memory\m1.A$rdmux[0][3][1]$a$1645 [3] $memory\m1.A$rdmux[0][3][1]$a$1645 [0] }
      New connections: { $memory\m1.A$rdmux[0][3][1]$a$1645 [7:4] $memory\m1.A$rdmux[0][3][1]$a$1645 [2:1] } = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][4][3]$1674:
      Old ports: A=8'00000011, B=8'00000101, Y=$memory\m1.A$rdmux[0][3][1]$b$1646
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[0][3][1]$b$1646 [2:1]
      New connections: { $memory\m1.A$rdmux[0][3][1]$b$1646 [7:3] $memory\m1.A$rdmux[0][3][1]$b$1646 [0] } = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][4][4]$1677:
      Old ports: A=8'00000111, B=8'00001001, Y=$memory\m1.A$rdmux[0][3][2]$a$1648
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[0][3][2]$a$1648 [3] $memory\m1.A$rdmux[0][3][2]$a$1648 [1] }
      New connections: { $memory\m1.A$rdmux[0][3][2]$a$1648 [7:4] $memory\m1.A$rdmux[0][3][2]$a$1648 [2] $memory\m1.A$rdmux[0][3][2]$a$1648 [0] } = { 4'0000 $memory\m1.A$rdmux[0][3][2]$a$1648 [1] 1'1 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][4][5]$1680:
      Old ports: A=8'00000010, B=8'00000100, Y=$memory\m1.A$rdmux[0][3][2]$b$1649
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[0][3][2]$b$1649 [2:1]
      New connections: { $memory\m1.A$rdmux[0][3][2]$b$1649 [7:3] $memory\m1.A$rdmux[0][3][2]$b$1649 [0] } = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][4][6]$1683:
      Old ports: A=8'00000110, B=8'00001000, Y=$memory\m1.A$rdmux[0][3][3]$a$1651
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[0][3][3]$a$1651 [3] $memory\m1.A$rdmux[0][3][3]$a$1651 [1] }
      New connections: { $memory\m1.A$rdmux[0][3][3]$a$1651 [7:4] $memory\m1.A$rdmux[0][3][3]$a$1651 [2] $memory\m1.A$rdmux[0][3][3]$a$1651 [0] } = { 4'0000 $memory\m1.A$rdmux[0][3][3]$a$1651 [1] 1'0 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][4][7]$1686:
      Old ports: A=8'00001010, B=8'00000011, Y=$memory\m1.A$rdmux[0][3][3]$b$1652
      New ports: A=2'10, B=2'01, Y={ $memory\m1.A$rdmux[0][3][3]$b$1652 [3] $memory\m1.A$rdmux[0][3][3]$b$1652 [0] }
      New connections: { $memory\m1.A$rdmux[0][3][3]$b$1652 [7:4] $memory\m1.A$rdmux[0][3][3]$b$1652 [2:1] } = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][4][8]$1689:
      Old ports: A=8'00000101, B=8'00000111, Y=$memory\m1.A$rdmux[0][3][4]$a$1654
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[0][3][4]$a$1654 [1]
      New connections: { $memory\m1.A$rdmux[0][3][4]$a$1654 [7:2] $memory\m1.A$rdmux[0][3][4]$a$1654 [0] } = 7'0000011
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][4][9]$1692:
      Old ports: A=8'00001001, B=8'00001011, Y=$memory\m1.A$rdmux[0][3][4]$b$1655
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[0][3][4]$b$1655 [1]
      New connections: { $memory\m1.A$rdmux[0][3][4]$b$1655 [7:2] $memory\m1.A$rdmux[0][3][4]$b$1655 [0] } = 7'0000101
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][4][0]$1854:
      Old ports: A=8'00000001, B=8'00000011, Y=$memory\m1.A$rdmux[1][3][0]$a$1831
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[1][3][0]$a$1831 [1]
      New connections: { $memory\m1.A$rdmux[1][3][0]$a$1831 [7:2] $memory\m1.A$rdmux[1][3][0]$a$1831 [0] } = 7'0000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][4][2]$1860:
      Old ports: A=8'00001001, B=8'00000010, Y=$memory\m1.A$rdmux[1][3][1]$a$1834
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[1][3][1]$a$1834 [1:0]
      New connections: $memory\m1.A$rdmux[1][3][1]$a$1834 [7:2] = { 4'0000 $memory\m1.A$rdmux[1][3][1]$a$1834 [0] 1'0 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][4][3]$1863:
      Old ports: A=8'00000100, B=8'00000110, Y=$memory\m1.A$rdmux[1][3][1]$b$1835
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[1][3][1]$b$1835 [1]
      New connections: { $memory\m1.A$rdmux[1][3][1]$b$1835 [7:2] $memory\m1.A$rdmux[1][3][1]$b$1835 [0] } = 7'0000010
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][4][5]$1869:
      Old ports: A=8'00000011, B=8'00000101, Y=$memory\m1.A$rdmux[1][3][2]$b$1838
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[1][3][2]$b$1838 [2:1]
      New connections: { $memory\m1.A$rdmux[1][3][2]$b$1838 [7:3] $memory\m1.A$rdmux[1][3][2]$b$1838 [0] } = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][4][6]$1872:
      Old ports: A=8'00000111, B=8'00001001, Y=$memory\m1.A$rdmux[1][3][3]$a$1840
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[1][3][3]$a$1840 [3] $memory\m1.A$rdmux[1][3][3]$a$1840 [1] }
      New connections: { $memory\m1.A$rdmux[1][3][3]$a$1840 [7:4] $memory\m1.A$rdmux[1][3][3]$a$1840 [2] $memory\m1.A$rdmux[1][3][3]$a$1840 [0] } = { 4'0000 $memory\m1.A$rdmux[1][3][3]$a$1840 [1] 1'1 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][4][9]$1881:
      Old ports: A=8'00001010, B=8'00001100, Y=$memory\m1.A$rdmux[1][3][4]$b$1844
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[1][3][4]$b$1844 [2:1]
      New connections: { $memory\m1.A$rdmux[1][3][4]$b$1844 [7:3] $memory\m1.A$rdmux[1][3][4]$b$1844 [0] } = 6'000010
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][4][4]$2055:
      Old ports: A=8'00000111, B=8'00001001, Y=$memory\m1.A$rdmux[2][3][2]$a$2026
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[2][3][2]$a$2026 [3] $memory\m1.A$rdmux[2][3][2]$a$2026 [1] }
      New connections: { $memory\m1.A$rdmux[2][3][2]$a$2026 [7:4] $memory\m1.A$rdmux[2][3][2]$a$2026 [2] $memory\m1.A$rdmux[2][3][2]$a$2026 [0] } = { 4'0000 $memory\m1.A$rdmux[2][3][2]$a$2026 [1] 1'1 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][4][5]$2058:
      Old ports: A=8'00000010, B=8'00000100, Y=$memory\m1.A$rdmux[2][3][2]$b$2027
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[2][3][2]$b$2027 [2:1]
      New connections: { $memory\m1.A$rdmux[2][3][2]$b$2027 [7:3] $memory\m1.A$rdmux[2][3][2]$b$2027 [0] } = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][4][6]$2061:
      Old ports: A=8'00000110, B=8'00001000, Y=$memory\m1.A$rdmux[2][3][3]$a$2029
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[2][3][3]$a$2029 [3] $memory\m1.A$rdmux[2][3][3]$a$2029 [1] }
      New connections: { $memory\m1.A$rdmux[2][3][3]$a$2029 [7:4] $memory\m1.A$rdmux[2][3][3]$a$2029 [2] $memory\m1.A$rdmux[2][3][3]$a$2029 [0] } = { 4'0000 $memory\m1.A$rdmux[2][3][3]$a$2029 [1] 1'0 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][4][7]$2064:
      Old ports: A=8'00001010, B=8'00000011, Y=$memory\m1.A$rdmux[2][3][3]$b$2030
      New ports: A=2'10, B=2'01, Y={ $memory\m1.A$rdmux[2][3][3]$b$2030 [3] $memory\m1.A$rdmux[2][3][3]$b$2030 [0] }
      New connections: { $memory\m1.A$rdmux[2][3][3]$b$2030 [7:4] $memory\m1.A$rdmux[2][3][3]$b$2030 [2:1] } = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][4][8]$2067:
      Old ports: A=8'00000101, B=8'00000111, Y=$memory\m1.A$rdmux[2][3][4]$a$2032
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[2][3][4]$a$2032 [1]
      New connections: { $memory\m1.A$rdmux[2][3][4]$a$2032 [7:2] $memory\m1.A$rdmux[2][3][4]$a$2032 [0] } = 7'0000011
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][4][9]$2070:
      Old ports: A=8'00001001, B=8'00001011, Y=$memory\m1.A$rdmux[2][3][4]$b$2033
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[2][3][4]$b$2033 [1]
      New connections: { $memory\m1.A$rdmux[2][3][4]$b$2033 [7:2] $memory\m1.A$rdmux[2][3][4]$b$2033 [0] } = 7'0000101
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][4][0]$2232:
      Old ports: A=8'00000001, B=8'00000011, Y=$memory\m1.A$rdmux[3][3][0]$a$2209
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[3][3][0]$a$2209 [1]
      New connections: { $memory\m1.A$rdmux[3][3][0]$a$2209 [7:2] $memory\m1.A$rdmux[3][3][0]$a$2209 [0] } = 7'0000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][4][1]$2235:
      Old ports: A=8'00000101, B=8'00000111, Y=$memory\m1.A$rdmux[3][3][0]$b$2210
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[3][3][0]$b$2210 [1]
      New connections: { $memory\m1.A$rdmux[3][3][0]$b$2210 [7:2] $memory\m1.A$rdmux[3][3][0]$b$2210 [0] } = 7'0000011
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][4][2]$2238:
      Old ports: A=8'00001001, B=8'00000010, Y=$memory\m1.A$rdmux[3][3][1]$a$2212
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[3][3][1]$a$2212 [1:0]
      New connections: $memory\m1.A$rdmux[3][3][1]$a$2212 [7:2] = { 4'0000 $memory\m1.A$rdmux[3][3][1]$a$2212 [0] 1'0 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][4][3]$2241:
      Old ports: A=8'00000100, B=8'00000110, Y=$memory\m1.A$rdmux[3][3][1]$b$2213
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[3][3][1]$b$2213 [1]
      New connections: { $memory\m1.A$rdmux[3][3][1]$b$2213 [7:2] $memory\m1.A$rdmux[3][3][1]$b$2213 [0] } = 7'0000010
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][4][4]$2244:
      Old ports: A=8'00001000, B=8'00001010, Y=$memory\m1.A$rdmux[3][3][2]$a$2215
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[3][3][2]$a$2215 [1]
      New connections: { $memory\m1.A$rdmux[3][3][2]$a$2215 [7:2] $memory\m1.A$rdmux[3][3][2]$a$2215 [0] } = 7'0000100
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][4][5]$2247:
      Old ports: A=8'00000011, B=8'00000101, Y=$memory\m1.A$rdmux[3][3][2]$b$2216
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[3][3][2]$b$2216 [2:1]
      New connections: { $memory\m1.A$rdmux[3][3][2]$b$2216 [7:3] $memory\m1.A$rdmux[3][3][2]$b$2216 [0] } = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][4][6]$2250:
      Old ports: A=8'00000111, B=8'00001001, Y=$memory\m1.A$rdmux[3][3][3]$a$2218
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[3][3][3]$a$2218 [3] $memory\m1.A$rdmux[3][3][3]$a$2218 [1] }
      New connections: { $memory\m1.A$rdmux[3][3][3]$a$2218 [7:4] $memory\m1.A$rdmux[3][3][3]$a$2218 [2] $memory\m1.A$rdmux[3][3][3]$a$2218 [0] } = { 4'0000 $memory\m1.A$rdmux[3][3][3]$a$2218 [1] 1'1 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][4][7]$2253:
      Old ports: A=8'00001011, B=8'00000100, Y=$memory\m1.A$rdmux[3][3][3]$b$2219
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[3][3][3]$b$2219 [2] $memory\m1.A$rdmux[3][3][3]$b$2219 [0] }
      New connections: { $memory\m1.A$rdmux[3][3][3]$b$2219 [7:3] $memory\m1.A$rdmux[3][3][3]$b$2219 [1] } = { 4'0000 $memory\m1.A$rdmux[3][3][3]$b$2219 [0] $memory\m1.A$rdmux[3][3][3]$b$2219 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][4][8]$2256:
      Old ports: A=8'00000110, B=8'00001000, Y=$memory\m1.A$rdmux[3][3][4]$a$2221
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[3][3][4]$a$2221 [3] $memory\m1.A$rdmux[3][3][4]$a$2221 [1] }
      New connections: { $memory\m1.A$rdmux[3][3][4]$a$2221 [7:4] $memory\m1.A$rdmux[3][3][4]$a$2221 [2] $memory\m1.A$rdmux[3][3][4]$a$2221 [0] } = { 4'0000 $memory\m1.A$rdmux[3][3][4]$a$2221 [1] 1'0 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][4][9]$2259:
      Old ports: A=8'00001010, B=8'00001100, Y=$memory\m1.A$rdmux[3][3][4]$b$2222
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[3][3][4]$b$2222 [2:1]
      New connections: { $memory\m1.A$rdmux[3][3][4]$b$2222 [7:3] $memory\m1.A$rdmux[3][3][4]$b$2222 [0] } = 6'000010
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][4][0]$2421:
      Old ports: A=8'00000000, B=8'00000010, Y=$memory\m1.A$rdmux[4][3][0]$a$2398
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[4][3][0]$a$2398 [1]
      New connections: { $memory\m1.A$rdmux[4][3][0]$a$2398 [7:2] $memory\m1.A$rdmux[4][3][0]$a$2398 [0] } = 7'0000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][4][1]$2424:
      Old ports: A=8'00000100, B=8'00000110, Y=$memory\m1.A$rdmux[4][3][0]$b$2399
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[4][3][0]$b$2399 [1]
      New connections: { $memory\m1.A$rdmux[4][3][0]$b$2399 [7:2] $memory\m1.A$rdmux[4][3][0]$b$2399 [0] } = 7'0000010
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][4][2]$2427:
      Old ports: A=8'00001000, B=8'00000001, Y=$memory\m1.A$rdmux[4][3][1]$a$2401
      New ports: A=2'10, B=2'01, Y={ $memory\m1.A$rdmux[4][3][1]$a$2401 [3] $memory\m1.A$rdmux[4][3][1]$a$2401 [0] }
      New connections: { $memory\m1.A$rdmux[4][3][1]$a$2401 [7:4] $memory\m1.A$rdmux[4][3][1]$a$2401 [2:1] } = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][4][3]$2430:
      Old ports: A=8'00000011, B=8'00000101, Y=$memory\m1.A$rdmux[4][3][1]$b$2402
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[4][3][1]$b$2402 [2:1]
      New connections: { $memory\m1.A$rdmux[4][3][1]$b$2402 [7:3] $memory\m1.A$rdmux[4][3][1]$b$2402 [0] } = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][4][4]$2433:
      Old ports: A=8'00000111, B=8'00001001, Y=$memory\m1.A$rdmux[4][3][2]$a$2404
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[4][3][2]$a$2404 [3] $memory\m1.A$rdmux[4][3][2]$a$2404 [1] }
      New connections: { $memory\m1.A$rdmux[4][3][2]$a$2404 [7:4] $memory\m1.A$rdmux[4][3][2]$a$2404 [2] $memory\m1.A$rdmux[4][3][2]$a$2404 [0] } = { 4'0000 $memory\m1.A$rdmux[4][3][2]$a$2404 [1] 1'1 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][4][5]$2436:
      Old ports: A=8'00000010, B=8'00000100, Y=$memory\m1.A$rdmux[4][3][2]$b$2405
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[4][3][2]$b$2405 [2:1]
      New connections: { $memory\m1.A$rdmux[4][3][2]$b$2405 [7:3] $memory\m1.A$rdmux[4][3][2]$b$2405 [0] } = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][4][6]$2439:
      Old ports: A=8'00000110, B=8'00001000, Y=$memory\m1.A$rdmux[4][3][3]$a$2407
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[4][3][3]$a$2407 [3] $memory\m1.A$rdmux[4][3][3]$a$2407 [1] }
      New connections: { $memory\m1.A$rdmux[4][3][3]$a$2407 [7:4] $memory\m1.A$rdmux[4][3][3]$a$2407 [2] $memory\m1.A$rdmux[4][3][3]$a$2407 [0] } = { 4'0000 $memory\m1.A$rdmux[4][3][3]$a$2407 [1] 1'0 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][4][7]$2442:
      Old ports: A=8'00001010, B=8'00000011, Y=$memory\m1.A$rdmux[4][3][3]$b$2408
      New ports: A=2'10, B=2'01, Y={ $memory\m1.A$rdmux[4][3][3]$b$2408 [3] $memory\m1.A$rdmux[4][3][3]$b$2408 [0] }
      New connections: { $memory\m1.A$rdmux[4][3][3]$b$2408 [7:4] $memory\m1.A$rdmux[4][3][3]$b$2408 [2:1] } = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][4][8]$2445:
      Old ports: A=8'00000101, B=8'00000111, Y=$memory\m1.A$rdmux[4][3][4]$a$2410
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[4][3][4]$a$2410 [1]
      New connections: { $memory\m1.A$rdmux[4][3][4]$a$2410 [7:2] $memory\m1.A$rdmux[4][3][4]$a$2410 [0] } = 7'0000011
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][4][9]$2448:
      Old ports: A=8'00001001, B=8'00001011, Y=$memory\m1.A$rdmux[4][3][4]$b$2411
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[4][3][4]$b$2411 [1]
      New connections: { $memory\m1.A$rdmux[4][3][4]$b$2411 [7:2] $memory\m1.A$rdmux[4][3][4]$b$2411 [0] } = 7'0000101
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][4][1]$2613:
      Old ports: A=8'00000101, B=8'00000111, Y=$memory\m1.A$rdmux[1][3][0]$b$1832
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[1][3][0]$b$1832 [1]
      New connections: { $memory\m1.A$rdmux[1][3][0]$b$1832 [7:2] $memory\m1.A$rdmux[1][3][0]$b$1832 [0] } = 7'0000011
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][4][4]$2622:
      Old ports: A=8'00001000, B=8'00001010, Y=$memory\m1.A$rdmux[1][3][2]$a$1837
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[1][3][2]$a$1837 [1]
      New connections: { $memory\m1.A$rdmux[1][3][2]$a$1837 [7:2] $memory\m1.A$rdmux[1][3][2]$a$1837 [0] } = 7'0000100
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][4][7]$2631:
      Old ports: A=8'00001011, B=8'00000100, Y=$memory\m1.A$rdmux[1][3][3]$b$1841
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[1][3][3]$b$1841 [2] $memory\m1.A$rdmux[1][3][3]$b$1841 [0] }
      New connections: { $memory\m1.A$rdmux[1][3][3]$b$1841 [7:3] $memory\m1.A$rdmux[1][3][3]$b$1841 [1] } = { 4'0000 $memory\m1.A$rdmux[1][3][3]$b$1841 [0] $memory\m1.A$rdmux[1][3][3]$b$1841 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][4][8]$2634:
      Old ports: A=8'00000110, B=8'00001000, Y=$memory\m1.A$rdmux[1][3][4]$a$1843
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[1][3][4]$a$1843 [3] $memory\m1.A$rdmux[1][3][4]$a$1843 [1] }
      New connections: { $memory\m1.A$rdmux[1][3][4]$a$1843 [7:4] $memory\m1.A$rdmux[1][3][4]$a$1843 [2] $memory\m1.A$rdmux[1][3][4]$a$1843 [0] } = { 4'0000 $memory\m1.A$rdmux[1][3][4]$a$1843 [1] 1'0 }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][4][0]$2799:
      Old ports: A=8'00000000, B=8'00000010, Y=$memory\m1.A$rdmux[2][3][0]$a$2020
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[2][3][0]$a$2020 [1]
      New connections: { $memory\m1.A$rdmux[2][3][0]$a$2020 [7:2] $memory\m1.A$rdmux[2][3][0]$a$2020 [0] } = 7'0000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][4][1]$2802:
      Old ports: A=8'00000100, B=8'00000110, Y=$memory\m1.A$rdmux[2][3][0]$b$2021
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[2][3][0]$b$2021 [1]
      New connections: { $memory\m1.A$rdmux[2][3][0]$b$2021 [7:2] $memory\m1.A$rdmux[2][3][0]$b$2021 [0] } = 7'0000010
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][4][2]$2805:
      Old ports: A=8'00001000, B=8'00000001, Y=$memory\m1.A$rdmux[2][3][1]$a$2023
      New ports: A=2'10, B=2'01, Y={ $memory\m1.A$rdmux[2][3][1]$a$2023 [3] $memory\m1.A$rdmux[2][3][1]$a$2023 [0] }
      New connections: { $memory\m1.A$rdmux[2][3][1]$a$2023 [7:4] $memory\m1.A$rdmux[2][3][1]$a$2023 [2:1] } = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][4][3]$2808:
      Old ports: A=8'00000011, B=8'00000101, Y=$memory\m1.A$rdmux[2][3][1]$b$2024
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[2][3][1]$b$2024 [2:1]
      New connections: { $memory\m1.A$rdmux[2][3][1]$b$2024 [7:3] $memory\m1.A$rdmux[2][3][1]$b$2024 [0] } = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][0]$3036:
      Old ports: A=8'00000000, B=8'00000001, Y=$memory\m1.A$rdmux[7][4][0]$a$2989
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][4][0]$a$2989 [0]
      New connections: $memory\m1.A$rdmux[7][4][0]$a$2989 [7:1] = 7'0000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][10]$3066:
      Old ports: A=8'00000010, B=8'00000011, Y=$memory\m1.A$rdmux[7][4][5]$a$3004
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][4][5]$a$3004 [0]
      New connections: $memory\m1.A$rdmux[7][4][5]$a$3004 [7:1] = 7'0000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][11]$3069:
      Old ports: A=8'00000100, B=8'00000101, Y=$memory\m1.A$rdmux[7][4][5]$b$3005
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][4][5]$b$3005 [0]
      New connections: $memory\m1.A$rdmux[7][4][5]$b$3005 [7:1] = 7'0000010
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][12]$3072:
      Old ports: A=8'00000110, B=8'00000111, Y=$memory\m1.A$rdmux[7][4][6]$a$3007
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][4][6]$a$3007 [0]
      New connections: $memory\m1.A$rdmux[7][4][6]$a$3007 [7:1] = 7'0000011
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][13]$3075:
      Old ports: A=8'00001000, B=8'00001001, Y=$memory\m1.A$rdmux[7][4][6]$b$3008
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][4][6]$b$3008 [0]
      New connections: $memory\m1.A$rdmux[7][4][6]$b$3008 [7:1] = 7'0000100
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][14]$3078:
      Old ports: A=8'00001010, B=8'00001011, Y=$memory\m1.A$rdmux[7][4][7]$a$3010
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][4][7]$a$3010 [0]
      New connections: $memory\m1.A$rdmux[7][4][7]$a$3010 [7:1] = 7'0000101
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][15]$3081:
      Old ports: A=8'00000011, B=8'00000100, Y=$memory\m1.A$rdmux[7][4][7]$b$3011
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[7][4][7]$b$3011 [2] $memory\m1.A$rdmux[7][4][7]$b$3011 [0] }
      New connections: { $memory\m1.A$rdmux[7][4][7]$b$3011 [7:3] $memory\m1.A$rdmux[7][4][7]$b$3011 [1] } = { 5'00000 $memory\m1.A$rdmux[7][4][7]$b$3011 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][16]$3084:
      Old ports: A=8'00000101, B=8'00000110, Y=$memory\m1.A$rdmux[7][4][8]$a$3013
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[7][4][8]$a$3013 [1:0]
      New connections: $memory\m1.A$rdmux[7][4][8]$a$3013 [7:2] = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][17]$3087:
      Old ports: A=8'00000111, B=8'00001000, Y=$memory\m1.A$rdmux[7][4][8]$b$3014
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[7][4][8]$b$3014 [3] $memory\m1.A$rdmux[7][4][8]$b$3014 [0] }
      New connections: { $memory\m1.A$rdmux[7][4][8]$b$3014 [7:4] $memory\m1.A$rdmux[7][4][8]$b$3014 [2:1] } = { 4'0000 $memory\m1.A$rdmux[7][4][8]$b$3014 [0] $memory\m1.A$rdmux[7][4][8]$b$3014 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][18]$3090:
      Old ports: A=8'00001001, B=8'00001010, Y=$memory\m1.A$rdmux[7][4][9]$a$3016
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[7][4][9]$a$3016 [1:0]
      New connections: $memory\m1.A$rdmux[7][4][9]$a$3016 [7:2] = 6'000010
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][19]$3093:
      Old ports: A=8'00001011, B=8'00001100, Y=$memory\m1.A$rdmux[7][4][9]$b$3017
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[7][4][9]$b$3017 [2] $memory\m1.A$rdmux[7][4][9]$b$3017 [0] }
      New connections: { $memory\m1.A$rdmux[7][4][9]$b$3017 [7:3] $memory\m1.A$rdmux[7][4][9]$b$3017 [1] } = { 5'00001 $memory\m1.A$rdmux[7][4][9]$b$3017 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][1]$3039:
      Old ports: A=8'00000010, B=8'00000011, Y=$memory\m1.A$rdmux[7][4][0]$b$2990
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][4][0]$b$2990 [0]
      New connections: $memory\m1.A$rdmux[7][4][0]$b$2990 [7:1] = 7'0000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][2]$3042:
      Old ports: A=8'00000100, B=8'00000101, Y=$memory\m1.A$rdmux[7][4][1]$a$2992
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][4][1]$a$2992 [0]
      New connections: $memory\m1.A$rdmux[7][4][1]$a$2992 [7:1] = 7'0000010
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][3]$3045:
      Old ports: A=8'00000110, B=8'00000111, Y=$memory\m1.A$rdmux[7][4][1]$b$2993
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][4][1]$b$2993 [0]
      New connections: $memory\m1.A$rdmux[7][4][1]$b$2993 [7:1] = 7'0000011
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][4]$3048:
      Old ports: A=8'00001000, B=8'00001001, Y=$memory\m1.A$rdmux[7][4][2]$a$2995
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][4][2]$a$2995 [0]
      New connections: $memory\m1.A$rdmux[7][4][2]$a$2995 [7:1] = 7'0000100
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][5]$3051:
      Old ports: A=8'00000001, B=8'00000010, Y=$memory\m1.A$rdmux[7][4][2]$b$2996
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[7][4][2]$b$2996 [1:0]
      New connections: $memory\m1.A$rdmux[7][4][2]$b$2996 [7:2] = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][6]$3054:
      Old ports: A=8'00000011, B=8'00000100, Y=$memory\m1.A$rdmux[7][4][3]$a$2998
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[7][4][3]$a$2998 [2] $memory\m1.A$rdmux[7][4][3]$a$2998 [0] }
      New connections: { $memory\m1.A$rdmux[7][4][3]$a$2998 [7:3] $memory\m1.A$rdmux[7][4][3]$a$2998 [1] } = { 5'00000 $memory\m1.A$rdmux[7][4][3]$a$2998 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][7]$3057:
      Old ports: A=8'00000101, B=8'00000110, Y=$memory\m1.A$rdmux[7][4][3]$b$2999
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[7][4][3]$b$2999 [1:0]
      New connections: $memory\m1.A$rdmux[7][4][3]$b$2999 [7:2] = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][8]$3060:
      Old ports: A=8'00000111, B=8'00001000, Y=$memory\m1.A$rdmux[7][4][4]$a$3001
      New ports: A=2'01, B=2'10, Y={ $memory\m1.A$rdmux[7][4][4]$a$3001 [3] $memory\m1.A$rdmux[7][4][4]$a$3001 [0] }
      New connections: { $memory\m1.A$rdmux[7][4][4]$a$3001 [7:4] $memory\m1.A$rdmux[7][4][4]$a$3001 [2:1] } = { 4'0000 $memory\m1.A$rdmux[7][4][4]$a$3001 [0] $memory\m1.A$rdmux[7][4][4]$a$3001 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][5][9]$3063:
      Old ports: A=8'00001001, B=8'00001010, Y=$memory\m1.A$rdmux[7][4][4]$b$3002
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[7][4][4]$b$3002 [1:0]
      New connections: $memory\m1.A$rdmux[7][4][4]$b$3002 [7:2] = 6'000010
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[0][0][0]$3152:
      Old ports: A=8'00000110, B=8'x, Y=$techmap1335$flatten\m1.$mul$matmul.v:109$562.B
      New ports: A=2'10, B=2'x, Y=$techmap1335$flatten\m1.$mul$matmul.v:109$562.B [1:0]
      New connections: $techmap1335$flatten\m1.$mul$matmul.v:109$562.B [7:2] = { $techmap1335$flatten\m1.$mul$matmul.v:109$562.B [0] $techmap1335$flatten\m1.$mul$matmul.v:109$562.B [0] $techmap1335$flatten\m1.$mul$matmul.v:109$562.B [0] $techmap1335$flatten\m1.$mul$matmul.v:109$562.B [0] $techmap1335$flatten\m1.$mul$matmul.v:109$562.B [0] $techmap1335$flatten\m1.$mul$matmul.v:109$562.B [1] }
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[1][0][0]$3197:
      Old ports: A=8'00000101, B=8'x, Y=$techmap1336$flatten\m1.$mul$matmul.v:109$552.B
      New ports: A=2'01, B=2'x, Y=$techmap1336$flatten\m1.$mul$matmul.v:109$552.B [1:0]
      New connections: $techmap1336$flatten\m1.$mul$matmul.v:109$552.B [7:2] = { $techmap1336$flatten\m1.$mul$matmul.v:109$552.B [1] $techmap1336$flatten\m1.$mul$matmul.v:109$552.B [1] $techmap1336$flatten\m1.$mul$matmul.v:109$552.B [1] $techmap1336$flatten\m1.$mul$matmul.v:109$552.B [1] $techmap1336$flatten\m1.$mul$matmul.v:109$552.B [1:0] }
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[2][0][0]$3242:
      Old ports: A=8'00000100, B=8'x, Y=$techmap1337$flatten\m1.$mul$matmul.v:109$542.B
      New ports: A=2'10, B=2'x, Y={ $techmap1337$flatten\m1.$mul$matmul.v:109$542.B [2] $techmap1337$flatten\m1.$mul$matmul.v:109$542.B [0] }
      New connections: { $techmap1337$flatten\m1.$mul$matmul.v:109$542.B [7:3] $techmap1337$flatten\m1.$mul$matmul.v:109$542.B [1] } = { $techmap1337$flatten\m1.$mul$matmul.v:109$542.B [0] $techmap1337$flatten\m1.$mul$matmul.v:109$542.B [0] $techmap1337$flatten\m1.$mul$matmul.v:109$542.B [0] $techmap1337$flatten\m1.$mul$matmul.v:109$542.B [0] $techmap1337$flatten\m1.$mul$matmul.v:109$542.B [0] $techmap1337$flatten\m1.$mul$matmul.v:109$542.B [0] }
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[3][0][0]$3287:
      Old ports: A=8'00000011, B=8'x, Y=$techmap1338$flatten\m1.$mul$matmul.v:109$532.B
      New ports: A=2'01, B=2'x, Y={ $techmap1338$flatten\m1.$mul$matmul.v:109$532.B [2] $techmap1338$flatten\m1.$mul$matmul.v:109$532.B [0] }
      New connections: { $techmap1338$flatten\m1.$mul$matmul.v:109$532.B [7:3] $techmap1338$flatten\m1.$mul$matmul.v:109$532.B [1] } = { $techmap1338$flatten\m1.$mul$matmul.v:109$532.B [2] $techmap1338$flatten\m1.$mul$matmul.v:109$532.B [2] $techmap1338$flatten\m1.$mul$matmul.v:109$532.B [2] $techmap1338$flatten\m1.$mul$matmul.v:109$532.B [2] $techmap1338$flatten\m1.$mul$matmul.v:109$532.B [2] $techmap1338$flatten\m1.$mul$matmul.v:109$532.B [0] }
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[4][0][0]$3332:
      Old ports: A=8'00000010, B=8'x, Y=$techmap1339$flatten\m1.$mul$matmul.v:109$522.B
      New ports: A=2'10, B=2'x, Y=$techmap1339$flatten\m1.$mul$matmul.v:109$522.B [1:0]
      New connections: $techmap1339$flatten\m1.$mul$matmul.v:109$522.B [7:2] = { $techmap1339$flatten\m1.$mul$matmul.v:109$522.B [0] $techmap1339$flatten\m1.$mul$matmul.v:109$522.B [0] $techmap1339$flatten\m1.$mul$matmul.v:109$522.B [0] $techmap1339$flatten\m1.$mul$matmul.v:109$522.B [0] $techmap1339$flatten\m1.$mul$matmul.v:109$522.B [0] $techmap1339$flatten\m1.$mul$matmul.v:109$522.B [0] }
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[5][0][0]$3377:
      Old ports: A=8'00000001, B=8'00001001, Y=$techmap1340$flatten\m1.$mul$matmul.v:109$512.B
      New ports: A=1'0, B=1'1, Y=$techmap1340$flatten\m1.$mul$matmul.v:109$512.B [3]
      New connections: { $techmap1340$flatten\m1.$mul$matmul.v:109$512.B [7:4] $techmap1340$flatten\m1.$mul$matmul.v:109$512.B [2:0] } = 7'0000001
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[6][0][0]$3422:
      Old ports: A=8'00000000, B=8'00001000, Y=$\m1.B$rdreg[6]$d
      New ports: A=1'0, B=1'1, Y=$\m1.B$rdreg[6]$d [3]
      New connections: { $\m1.B$rdreg[6]$d [7:4] $\m1.B$rdreg[6]$d [2:0] } = 7'0000000
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][3][0]$3488:
      Old ports: A=8'00000000, B=8'00000001, Y=$memory\m1.B$rdmux[7][2][0]$a$3477
      New ports: A=1'0, B=1'1, Y=$memory\m1.B$rdmux[7][2][0]$a$3477 [0]
      New connections: $memory\m1.B$rdmux[7][2][0]$a$3477 [7:1] = 7'0000000
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][3][1]$3491:
      Old ports: A=8'00000010, B=8'00000011, Y=$memory\m1.B$rdmux[7][2][0]$b$3478
      New ports: A=1'0, B=1'1, Y=$memory\m1.B$rdmux[7][2][0]$b$3478 [0]
      New connections: $memory\m1.B$rdmux[7][2][0]$b$3478 [7:1] = 7'0000001
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][3][2]$3494:
      Old ports: A=8'00000100, B=8'00000101, Y=$memory\m1.B$rdmux[7][2][1]$a$3480
      New ports: A=1'0, B=1'1, Y=$memory\m1.B$rdmux[7][2][1]$a$3480 [0]
      New connections: $memory\m1.B$rdmux[7][2][1]$a$3480 [7:1] = 7'0000010
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][3][3]$3497:
      Old ports: A=8'00000110, B=8'00000111, Y=$memory\m1.B$rdmux[7][2][1]$b$3481
      New ports: A=1'0, B=1'1, Y=$memory\m1.B$rdmux[7][2][1]$b$3481 [0]
      New connections: $memory\m1.B$rdmux[7][2][1]$b$3481 [7:1] = 7'0000011
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][3][4]$3500:
      Old ports: A=8'00001000, B=8'00001001, Y=$memory\m1.B$rdmux[7][2][2]$a$3483
      New ports: A=1'0, B=1'1, Y=$memory\m1.B$rdmux[7][2][2]$a$3483 [0]
      New connections: $memory\m1.B$rdmux[7][2][2]$a$3483 [7:1] = 7'0000100
  Optimizing cells in module \top.
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][3][0]$1641:
      Old ports: A=$memory\m1.A$rdmux[0][3][0]$a$1642, B=$memory\m1.A$rdmux[0][3][0]$b$1643, Y=$memory\m1.A$rdmux[0][2][0]$a$1630
      New ports: A={ 1'0 $memory\m1.A$rdmux[0][3][0]$a$1642 [1] }, B={ 1'1 $memory\m1.A$rdmux[0][3][0]$b$1643 [1] }, Y=$memory\m1.A$rdmux[0][2][0]$a$1630 [2:1]
      New connections: { $memory\m1.A$rdmux[0][2][0]$a$1630 [7:3] $memory\m1.A$rdmux[0][2][0]$a$1630 [0] } = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][3][1]$1644:
      Old ports: A=$memory\m1.A$rdmux[0][3][1]$a$1645, B=$memory\m1.A$rdmux[0][3][1]$b$1646, Y=$memory\m1.A$rdmux[0][2][0]$b$1631
      New ports: A={ $memory\m1.A$rdmux[0][3][1]$a$1645 [3] 2'00 $memory\m1.A$rdmux[0][3][1]$a$1645 [0] }, B={ 1'0 $memory\m1.A$rdmux[0][3][1]$b$1646 [2:1] 1'1 }, Y=$memory\m1.A$rdmux[0][2][0]$b$1631 [3:0]
      New connections: $memory\m1.A$rdmux[0][2][0]$b$1631 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][3][2]$1647:
      Old ports: A=$memory\m1.A$rdmux[0][3][2]$a$1648, B=$memory\m1.A$rdmux[0][3][2]$b$1649, Y=$memory\m1.A$rdmux[0][2][1]$a$1633
      New ports: A={ $memory\m1.A$rdmux[0][3][2]$a$1648 [3] $memory\m1.A$rdmux[0][3][2]$a$1648 [1] $memory\m1.A$rdmux[0][3][2]$a$1648 [1] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[0][3][2]$b$1649 [2:1] 1'0 }, Y=$memory\m1.A$rdmux[0][2][1]$a$1633 [3:0]
      New connections: $memory\m1.A$rdmux[0][2][1]$a$1633 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][3][3]$1650:
      Old ports: A=$memory\m1.A$rdmux[0][3][3]$a$1651, B=$memory\m1.A$rdmux[0][3][3]$b$1652, Y=$memory\m1.A$rdmux[0][2][1]$b$1634
      New ports: A={ $memory\m1.A$rdmux[0][3][3]$a$1651 [3] $memory\m1.A$rdmux[0][3][3]$a$1651 [1] $memory\m1.A$rdmux[0][3][3]$a$1651 [1] 1'0 }, B={ $memory\m1.A$rdmux[0][3][3]$b$1652 [3] 2'01 $memory\m1.A$rdmux[0][3][3]$b$1652 [0] }, Y=$memory\m1.A$rdmux[0][2][1]$b$1634 [3:0]
      New connections: $memory\m1.A$rdmux[0][2][1]$b$1634 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][3][4]$1653:
      Old ports: A=$memory\m1.A$rdmux[0][3][4]$a$1654, B=$memory\m1.A$rdmux[0][3][4]$b$1655, Y=$memory\m1.A$rdmux[0][2][2]$a$1636
      New ports: A={ 2'01 $memory\m1.A$rdmux[0][3][4]$a$1654 [1] }, B={ 2'10 $memory\m1.A$rdmux[0][3][4]$b$1655 [1] }, Y=$memory\m1.A$rdmux[0][2][2]$a$1636 [3:1]
      New connections: { $memory\m1.A$rdmux[0][2][2]$a$1636 [7:4] $memory\m1.A$rdmux[0][2][2]$a$1636 [0] } = 5'00001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][3][0]$1830:
      Old ports: A=$memory\m1.A$rdmux[1][3][0]$a$1831, B=$memory\m1.A$rdmux[1][3][0]$b$1832, Y=$memory\m1.A$rdmux[1][2][0]$a$1819
      New ports: A={ 1'0 $memory\m1.A$rdmux[1][3][0]$a$1831 [1] }, B={ 1'1 $memory\m1.A$rdmux[1][3][0]$b$1832 [1] }, Y=$memory\m1.A$rdmux[1][2][0]$a$1819 [2:1]
      New connections: { $memory\m1.A$rdmux[1][2][0]$a$1819 [7:3] $memory\m1.A$rdmux[1][2][0]$a$1819 [0] } = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][3][1]$1833:
      Old ports: A=$memory\m1.A$rdmux[1][3][1]$a$1834, B=$memory\m1.A$rdmux[1][3][1]$b$1835, Y=$memory\m1.A$rdmux[1][2][0]$b$1820
      New ports: A={ 1'0 $memory\m1.A$rdmux[1][3][1]$a$1834 [1:0] }, B={ 1'1 $memory\m1.A$rdmux[1][3][1]$b$1835 [1] 1'0 }, Y=$memory\m1.A$rdmux[1][2][0]$b$1820 [2:0]
      New connections: $memory\m1.A$rdmux[1][2][0]$b$1820 [7:3] = { 4'0000 $memory\m1.A$rdmux[1][2][0]$b$1820 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][3][2]$1836:
      Old ports: A=$memory\m1.A$rdmux[1][3][2]$a$1837, B=$memory\m1.A$rdmux[1][3][2]$b$1838, Y=$memory\m1.A$rdmux[1][2][1]$a$1822
      New ports: A={ 2'10 $memory\m1.A$rdmux[1][3][2]$a$1837 [1] 1'0 }, B={ 1'0 $memory\m1.A$rdmux[1][3][2]$b$1838 [2:1] 1'1 }, Y=$memory\m1.A$rdmux[1][2][1]$a$1822 [3:0]
      New connections: $memory\m1.A$rdmux[1][2][1]$a$1822 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][3][3]$1839:
      Old ports: A=$memory\m1.A$rdmux[1][3][3]$a$1840, B=$memory\m1.A$rdmux[1][3][3]$b$1841, Y=$memory\m1.A$rdmux[1][2][1]$b$1823
      New ports: A={ $memory\m1.A$rdmux[1][3][3]$a$1840 [3] $memory\m1.A$rdmux[1][3][3]$a$1840 [1] $memory\m1.A$rdmux[1][3][3]$a$1840 [1] 1'1 }, B={ $memory\m1.A$rdmux[1][3][3]$b$1841 [0] $memory\m1.A$rdmux[1][3][3]$b$1841 [2] $memory\m1.A$rdmux[1][3][3]$b$1841 [0] $memory\m1.A$rdmux[1][3][3]$b$1841 [0] }, Y=$memory\m1.A$rdmux[1][2][1]$b$1823 [3:0]
      New connections: $memory\m1.A$rdmux[1][2][1]$b$1823 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][3][4]$1842:
      Old ports: A=$memory\m1.A$rdmux[1][3][4]$a$1843, B=$memory\m1.A$rdmux[1][3][4]$b$1844, Y=$memory\m1.A$rdmux[1][2][2]$a$1825
      New ports: A={ $memory\m1.A$rdmux[1][3][4]$a$1843 [3] $memory\m1.A$rdmux[1][3][4]$a$1843 [1] $memory\m1.A$rdmux[1][3][4]$a$1843 [1] }, B={ 1'1 $memory\m1.A$rdmux[1][3][4]$b$1844 [2:1] }, Y=$memory\m1.A$rdmux[1][2][2]$a$1825 [3:1]
      New connections: { $memory\m1.A$rdmux[1][2][2]$a$1825 [7:4] $memory\m1.A$rdmux[1][2][2]$a$1825 [0] } = 5'00000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][3][0]$2019:
      Old ports: A=$memory\m1.A$rdmux[2][3][0]$a$2020, B=$memory\m1.A$rdmux[2][3][0]$b$2021, Y=$memory\m1.A$rdmux[2][2][0]$a$2008
      New ports: A={ 1'0 $memory\m1.A$rdmux[2][3][0]$a$2020 [1] }, B={ 1'1 $memory\m1.A$rdmux[2][3][0]$b$2021 [1] }, Y=$memory\m1.A$rdmux[2][2][0]$a$2008 [2:1]
      New connections: { $memory\m1.A$rdmux[2][2][0]$a$2008 [7:3] $memory\m1.A$rdmux[2][2][0]$a$2008 [0] } = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][3][1]$2022:
      Old ports: A=$memory\m1.A$rdmux[2][3][1]$a$2023, B=$memory\m1.A$rdmux[2][3][1]$b$2024, Y=$memory\m1.A$rdmux[2][2][0]$b$2009
      New ports: A={ $memory\m1.A$rdmux[2][3][1]$a$2023 [3] 2'00 $memory\m1.A$rdmux[2][3][1]$a$2023 [0] }, B={ 1'0 $memory\m1.A$rdmux[2][3][1]$b$2024 [2:1] 1'1 }, Y=$memory\m1.A$rdmux[2][2][0]$b$2009 [3:0]
      New connections: $memory\m1.A$rdmux[2][2][0]$b$2009 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][3][2]$2025:
      Old ports: A=$memory\m1.A$rdmux[2][3][2]$a$2026, B=$memory\m1.A$rdmux[2][3][2]$b$2027, Y=$memory\m1.A$rdmux[2][2][1]$a$2011
      New ports: A={ $memory\m1.A$rdmux[2][3][2]$a$2026 [3] $memory\m1.A$rdmux[2][3][2]$a$2026 [1] $memory\m1.A$rdmux[2][3][2]$a$2026 [1] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[2][3][2]$b$2027 [2:1] 1'0 }, Y=$memory\m1.A$rdmux[2][2][1]$a$2011 [3:0]
      New connections: $memory\m1.A$rdmux[2][2][1]$a$2011 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][3][3]$2028:
      Old ports: A=$memory\m1.A$rdmux[2][3][3]$a$2029, B=$memory\m1.A$rdmux[2][3][3]$b$2030, Y=$memory\m1.A$rdmux[2][2][1]$b$2012
      New ports: A={ $memory\m1.A$rdmux[2][3][3]$a$2029 [3] $memory\m1.A$rdmux[2][3][3]$a$2029 [1] $memory\m1.A$rdmux[2][3][3]$a$2029 [1] 1'0 }, B={ $memory\m1.A$rdmux[2][3][3]$b$2030 [3] 2'01 $memory\m1.A$rdmux[2][3][3]$b$2030 [0] }, Y=$memory\m1.A$rdmux[2][2][1]$b$2012 [3:0]
      New connections: $memory\m1.A$rdmux[2][2][1]$b$2012 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][3][4]$2031:
      Old ports: A=$memory\m1.A$rdmux[2][3][4]$a$2032, B=$memory\m1.A$rdmux[2][3][4]$b$2033, Y=$memory\m1.A$rdmux[2][2][2]$a$2014
      New ports: A={ 2'01 $memory\m1.A$rdmux[2][3][4]$a$2032 [1] }, B={ 2'10 $memory\m1.A$rdmux[2][3][4]$b$2033 [1] }, Y=$memory\m1.A$rdmux[2][2][2]$a$2014 [3:1]
      New connections: { $memory\m1.A$rdmux[2][2][2]$a$2014 [7:4] $memory\m1.A$rdmux[2][2][2]$a$2014 [0] } = 5'00001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][3][0]$2208:
      Old ports: A=$memory\m1.A$rdmux[3][3][0]$a$2209, B=$memory\m1.A$rdmux[3][3][0]$b$2210, Y=$memory\m1.A$rdmux[3][2][0]$a$2197
      New ports: A={ 1'0 $memory\m1.A$rdmux[3][3][0]$a$2209 [1] }, B={ 1'1 $memory\m1.A$rdmux[3][3][0]$b$2210 [1] }, Y=$memory\m1.A$rdmux[3][2][0]$a$2197 [2:1]
      New connections: { $memory\m1.A$rdmux[3][2][0]$a$2197 [7:3] $memory\m1.A$rdmux[3][2][0]$a$2197 [0] } = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][3][1]$2211:
      Old ports: A=$memory\m1.A$rdmux[3][3][1]$a$2212, B=$memory\m1.A$rdmux[3][3][1]$b$2213, Y=$memory\m1.A$rdmux[3][2][0]$b$2198
      New ports: A={ 1'0 $memory\m1.A$rdmux[3][3][1]$a$2212 [1:0] }, B={ 1'1 $memory\m1.A$rdmux[3][3][1]$b$2213 [1] 1'0 }, Y=$memory\m1.A$rdmux[3][2][0]$b$2198 [2:0]
      New connections: $memory\m1.A$rdmux[3][2][0]$b$2198 [7:3] = { 4'0000 $memory\m1.A$rdmux[3][2][0]$b$2198 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][3][2]$2214:
      Old ports: A=$memory\m1.A$rdmux[3][3][2]$a$2215, B=$memory\m1.A$rdmux[3][3][2]$b$2216, Y=$memory\m1.A$rdmux[3][2][1]$a$2200
      New ports: A={ 2'10 $memory\m1.A$rdmux[3][3][2]$a$2215 [1] 1'0 }, B={ 1'0 $memory\m1.A$rdmux[3][3][2]$b$2216 [2:1] 1'1 }, Y=$memory\m1.A$rdmux[3][2][1]$a$2200 [3:0]
      New connections: $memory\m1.A$rdmux[3][2][1]$a$2200 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][3][3]$2217:
      Old ports: A=$memory\m1.A$rdmux[3][3][3]$a$2218, B=$memory\m1.A$rdmux[3][3][3]$b$2219, Y=$memory\m1.A$rdmux[3][2][1]$b$2201
      New ports: A={ $memory\m1.A$rdmux[3][3][3]$a$2218 [3] $memory\m1.A$rdmux[3][3][3]$a$2218 [1] $memory\m1.A$rdmux[3][3][3]$a$2218 [1] 1'1 }, B={ $memory\m1.A$rdmux[3][3][3]$b$2219 [0] $memory\m1.A$rdmux[3][3][3]$b$2219 [2] $memory\m1.A$rdmux[3][3][3]$b$2219 [0] $memory\m1.A$rdmux[3][3][3]$b$2219 [0] }, Y=$memory\m1.A$rdmux[3][2][1]$b$2201 [3:0]
      New connections: $memory\m1.A$rdmux[3][2][1]$b$2201 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][3][4]$2220:
      Old ports: A=$memory\m1.A$rdmux[3][3][4]$a$2221, B=$memory\m1.A$rdmux[3][3][4]$b$2222, Y=$memory\m1.A$rdmux[3][2][2]$a$2203
      New ports: A={ $memory\m1.A$rdmux[3][3][4]$a$2221 [3] $memory\m1.A$rdmux[3][3][4]$a$2221 [1] $memory\m1.A$rdmux[3][3][4]$a$2221 [1] }, B={ 1'1 $memory\m1.A$rdmux[3][3][4]$b$2222 [2:1] }, Y=$memory\m1.A$rdmux[3][2][2]$a$2203 [3:1]
      New connections: { $memory\m1.A$rdmux[3][2][2]$a$2203 [7:4] $memory\m1.A$rdmux[3][2][2]$a$2203 [0] } = 5'00000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][3][0]$2397:
      Old ports: A=$memory\m1.A$rdmux[4][3][0]$a$2398, B=$memory\m1.A$rdmux[4][3][0]$b$2399, Y=$memory\m1.A$rdmux[4][2][0]$a$2386
      New ports: A={ 1'0 $memory\m1.A$rdmux[4][3][0]$a$2398 [1] }, B={ 1'1 $memory\m1.A$rdmux[4][3][0]$b$2399 [1] }, Y=$memory\m1.A$rdmux[4][2][0]$a$2386 [2:1]
      New connections: { $memory\m1.A$rdmux[4][2][0]$a$2386 [7:3] $memory\m1.A$rdmux[4][2][0]$a$2386 [0] } = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][3][1]$2400:
      Old ports: A=$memory\m1.A$rdmux[4][3][1]$a$2401, B=$memory\m1.A$rdmux[4][3][1]$b$2402, Y=$memory\m1.A$rdmux[4][2][0]$b$2387
      New ports: A={ $memory\m1.A$rdmux[4][3][1]$a$2401 [3] 2'00 $memory\m1.A$rdmux[4][3][1]$a$2401 [0] }, B={ 1'0 $memory\m1.A$rdmux[4][3][1]$b$2402 [2:1] 1'1 }, Y=$memory\m1.A$rdmux[4][2][0]$b$2387 [3:0]
      New connections: $memory\m1.A$rdmux[4][2][0]$b$2387 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][3][2]$2403:
      Old ports: A=$memory\m1.A$rdmux[4][3][2]$a$2404, B=$memory\m1.A$rdmux[4][3][2]$b$2405, Y=$memory\m1.A$rdmux[4][2][1]$a$2389
      New ports: A={ $memory\m1.A$rdmux[4][3][2]$a$2404 [3] $memory\m1.A$rdmux[4][3][2]$a$2404 [1] $memory\m1.A$rdmux[4][3][2]$a$2404 [1] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[4][3][2]$b$2405 [2:1] 1'0 }, Y=$memory\m1.A$rdmux[4][2][1]$a$2389 [3:0]
      New connections: $memory\m1.A$rdmux[4][2][1]$a$2389 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][3][3]$2406:
      Old ports: A=$memory\m1.A$rdmux[4][3][3]$a$2407, B=$memory\m1.A$rdmux[4][3][3]$b$2408, Y=$memory\m1.A$rdmux[4][2][1]$b$2390
      New ports: A={ $memory\m1.A$rdmux[4][3][3]$a$2407 [3] $memory\m1.A$rdmux[4][3][3]$a$2407 [1] $memory\m1.A$rdmux[4][3][3]$a$2407 [1] 1'0 }, B={ $memory\m1.A$rdmux[4][3][3]$b$2408 [3] 2'01 $memory\m1.A$rdmux[4][3][3]$b$2408 [0] }, Y=$memory\m1.A$rdmux[4][2][1]$b$2390 [3:0]
      New connections: $memory\m1.A$rdmux[4][2][1]$b$2390 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][3][4]$2409:
      Old ports: A=$memory\m1.A$rdmux[4][3][4]$a$2410, B=$memory\m1.A$rdmux[4][3][4]$b$2411, Y=$memory\m1.A$rdmux[4][2][2]$a$2392
      New ports: A={ 2'01 $memory\m1.A$rdmux[4][3][4]$a$2410 [1] }, B={ 2'10 $memory\m1.A$rdmux[4][3][4]$b$2411 [1] }, Y=$memory\m1.A$rdmux[4][2][2]$a$2392 [3:1]
      New connections: { $memory\m1.A$rdmux[4][2][2]$a$2392 [7:4] $memory\m1.A$rdmux[4][2][2]$a$2392 [0] } = 5'00001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][3][0]$2586:
      Old ports: A=$memory\m1.A$rdmux[1][3][0]$a$1831, B=$memory\m1.A$rdmux[1][3][0]$b$1832, Y=$memory\m1.A$rdmux[5][2][0]$a$2575
      New ports: A={ 1'0 $memory\m1.A$rdmux[1][3][0]$a$1831 [1] }, B={ 1'1 $memory\m1.A$rdmux[1][3][0]$b$1832 [1] }, Y=$memory\m1.A$rdmux[5][2][0]$a$2575 [2:1]
      New connections: { $memory\m1.A$rdmux[5][2][0]$a$2575 [7:3] $memory\m1.A$rdmux[5][2][0]$a$2575 [0] } = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][3][1]$2589:
      Old ports: A=$memory\m1.A$rdmux[1][3][1]$a$1834, B=$memory\m1.A$rdmux[1][3][1]$b$1835, Y=$memory\m1.A$rdmux[5][2][0]$b$2576
      New ports: A={ 1'0 $memory\m1.A$rdmux[1][3][1]$a$1834 [1:0] }, B={ 1'1 $memory\m1.A$rdmux[1][3][1]$b$1835 [1] 1'0 }, Y=$memory\m1.A$rdmux[5][2][0]$b$2576 [2:0]
      New connections: $memory\m1.A$rdmux[5][2][0]$b$2576 [7:3] = { 4'0000 $memory\m1.A$rdmux[5][2][0]$b$2576 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][3][2]$2592:
      Old ports: A=$memory\m1.A$rdmux[1][3][2]$a$1837, B=$memory\m1.A$rdmux[1][3][2]$b$1838, Y=$memory\m1.A$rdmux[5][2][1]$a$2578
      New ports: A={ 2'10 $memory\m1.A$rdmux[1][3][2]$a$1837 [1] 1'0 }, B={ 1'0 $memory\m1.A$rdmux[1][3][2]$b$1838 [2:1] 1'1 }, Y=$memory\m1.A$rdmux[5][2][1]$a$2578 [3:0]
      New connections: $memory\m1.A$rdmux[5][2][1]$a$2578 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][3][3]$2595:
      Old ports: A=$memory\m1.A$rdmux[1][3][3]$a$1840, B=$memory\m1.A$rdmux[1][3][3]$b$1841, Y=$memory\m1.A$rdmux[5][2][1]$b$2579
      New ports: A={ $memory\m1.A$rdmux[1][3][3]$a$1840 [3] $memory\m1.A$rdmux[1][3][3]$a$1840 [1] $memory\m1.A$rdmux[1][3][3]$a$1840 [1] 1'1 }, B={ $memory\m1.A$rdmux[1][3][3]$b$1841 [0] $memory\m1.A$rdmux[1][3][3]$b$1841 [2] $memory\m1.A$rdmux[1][3][3]$b$1841 [0] $memory\m1.A$rdmux[1][3][3]$b$1841 [0] }, Y=$memory\m1.A$rdmux[5][2][1]$b$2579 [3:0]
      New connections: $memory\m1.A$rdmux[5][2][1]$b$2579 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][3][4]$2598:
      Old ports: A=$memory\m1.A$rdmux[1][3][4]$a$1843, B=$memory\m1.A$rdmux[1][3][4]$b$1844, Y=$memory\m1.A$rdmux[5][2][2]$a$2581
      New ports: A={ $memory\m1.A$rdmux[1][3][4]$a$1843 [3] $memory\m1.A$rdmux[1][3][4]$a$1843 [1] $memory\m1.A$rdmux[1][3][4]$a$1843 [1] }, B={ 1'1 $memory\m1.A$rdmux[1][3][4]$b$1844 [2:1] }, Y=$memory\m1.A$rdmux[5][2][2]$a$2581 [3:1]
      New connections: { $memory\m1.A$rdmux[5][2][2]$a$2581 [7:4] $memory\m1.A$rdmux[5][2][2]$a$2581 [0] } = 5'00000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][3][0]$2775:
      Old ports: A=$memory\m1.A$rdmux[2][3][0]$a$2020, B=$memory\m1.A$rdmux[2][3][0]$b$2021, Y=$memory\m1.A$rdmux[6][2][0]$a$2764
      New ports: A={ 1'0 $memory\m1.A$rdmux[2][3][0]$a$2020 [1] }, B={ 1'1 $memory\m1.A$rdmux[2][3][0]$b$2021 [1] }, Y=$memory\m1.A$rdmux[6][2][0]$a$2764 [2:1]
      New connections: { $memory\m1.A$rdmux[6][2][0]$a$2764 [7:3] $memory\m1.A$rdmux[6][2][0]$a$2764 [0] } = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][3][1]$2778:
      Old ports: A=$memory\m1.A$rdmux[2][3][1]$a$2023, B=$memory\m1.A$rdmux[2][3][1]$b$2024, Y=$memory\m1.A$rdmux[6][2][0]$b$2765
      New ports: A={ $memory\m1.A$rdmux[2][3][1]$a$2023 [3] 2'00 $memory\m1.A$rdmux[2][3][1]$a$2023 [0] }, B={ 1'0 $memory\m1.A$rdmux[2][3][1]$b$2024 [2:1] 1'1 }, Y=$memory\m1.A$rdmux[6][2][0]$b$2765 [3:0]
      New connections: $memory\m1.A$rdmux[6][2][0]$b$2765 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][3][2]$2781:
      Old ports: A=$memory\m1.A$rdmux[2][3][2]$a$2026, B=$memory\m1.A$rdmux[2][3][2]$b$2027, Y=$memory\m1.A$rdmux[6][2][1]$a$2767
      New ports: A={ $memory\m1.A$rdmux[2][3][2]$a$2026 [3] $memory\m1.A$rdmux[2][3][2]$a$2026 [1] $memory\m1.A$rdmux[2][3][2]$a$2026 [1] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[2][3][2]$b$2027 [2:1] 1'0 }, Y=$memory\m1.A$rdmux[6][2][1]$a$2767 [3:0]
      New connections: $memory\m1.A$rdmux[6][2][1]$a$2767 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][3][3]$2784:
      Old ports: A=$memory\m1.A$rdmux[2][3][3]$a$2029, B=$memory\m1.A$rdmux[2][3][3]$b$2030, Y=$memory\m1.A$rdmux[6][2][1]$b$2768
      New ports: A={ $memory\m1.A$rdmux[2][3][3]$a$2029 [3] $memory\m1.A$rdmux[2][3][3]$a$2029 [1] $memory\m1.A$rdmux[2][3][3]$a$2029 [1] 1'0 }, B={ $memory\m1.A$rdmux[2][3][3]$b$2030 [3] 2'01 $memory\m1.A$rdmux[2][3][3]$b$2030 [0] }, Y=$memory\m1.A$rdmux[6][2][1]$b$2768 [3:0]
      New connections: $memory\m1.A$rdmux[6][2][1]$b$2768 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][3][4]$2787:
      Old ports: A=$memory\m1.A$rdmux[2][3][4]$a$2032, B=$memory\m1.A$rdmux[2][3][4]$b$2033, Y=$memory\m1.A$rdmux[6][2][2]$a$2770
      New ports: A={ 2'01 $memory\m1.A$rdmux[2][3][4]$a$2032 [1] }, B={ 2'10 $memory\m1.A$rdmux[2][3][4]$b$2033 [1] }, Y=$memory\m1.A$rdmux[6][2][2]$a$2770 [3:1]
      New connections: { $memory\m1.A$rdmux[6][2][2]$a$2770 [7:4] $memory\m1.A$rdmux[6][2][2]$a$2770 [0] } = 5'00001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][0]$2988:
      Old ports: A=$memory\m1.A$rdmux[7][4][0]$a$2989, B=$memory\m1.A$rdmux[7][4][0]$b$2990, Y=$memory\m1.A$rdmux[7][3][0]$a$2965
      New ports: A={ 1'0 $memory\m1.A$rdmux[7][4][0]$a$2989 [0] }, B={ 1'1 $memory\m1.A$rdmux[7][4][0]$b$2990 [0] }, Y=$memory\m1.A$rdmux[7][3][0]$a$2965 [1:0]
      New connections: $memory\m1.A$rdmux[7][3][0]$a$2965 [7:2] = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][1]$2991:
      Old ports: A=$memory\m1.A$rdmux[7][4][1]$a$2992, B=$memory\m1.A$rdmux[7][4][1]$b$2993, Y=$memory\m1.A$rdmux[7][3][0]$b$2966
      New ports: A={ 1'0 $memory\m1.A$rdmux[7][4][1]$a$2992 [0] }, B={ 1'1 $memory\m1.A$rdmux[7][4][1]$b$2993 [0] }, Y=$memory\m1.A$rdmux[7][3][0]$b$2966 [1:0]
      New connections: $memory\m1.A$rdmux[7][3][0]$b$2966 [7:2] = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][2]$2994:
      Old ports: A=$memory\m1.A$rdmux[7][4][2]$a$2995, B=$memory\m1.A$rdmux[7][4][2]$b$2996, Y=$memory\m1.A$rdmux[7][3][1]$a$2968
      New ports: A={ 2'10 $memory\m1.A$rdmux[7][4][2]$a$2995 [0] }, B={ 1'0 $memory\m1.A$rdmux[7][4][2]$b$2996 [1:0] }, Y={ $memory\m1.A$rdmux[7][3][1]$a$2968 [3] $memory\m1.A$rdmux[7][3][1]$a$2968 [1:0] }
      New connections: { $memory\m1.A$rdmux[7][3][1]$a$2968 [7:4] $memory\m1.A$rdmux[7][3][1]$a$2968 [2] } = 5'00000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][3]$2997:
      Old ports: A=$memory\m1.A$rdmux[7][4][3]$a$2998, B=$memory\m1.A$rdmux[7][4][3]$b$2999, Y=$memory\m1.A$rdmux[7][3][1]$b$2969
      New ports: A={ $memory\m1.A$rdmux[7][4][3]$a$2998 [2] $memory\m1.A$rdmux[7][4][3]$a$2998 [0] $memory\m1.A$rdmux[7][4][3]$a$2998 [0] }, B={ 1'1 $memory\m1.A$rdmux[7][4][3]$b$2999 [1:0] }, Y=$memory\m1.A$rdmux[7][3][1]$b$2969 [2:0]
      New connections: $memory\m1.A$rdmux[7][3][1]$b$2969 [7:3] = 5'00000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][4]$3000:
      Old ports: A=$memory\m1.A$rdmux[7][4][4]$a$3001, B=$memory\m1.A$rdmux[7][4][4]$b$3002, Y=$memory\m1.A$rdmux[7][3][2]$a$2971
      New ports: A={ $memory\m1.A$rdmux[7][4][4]$a$3001 [3] $memory\m1.A$rdmux[7][4][4]$a$3001 [0] $memory\m1.A$rdmux[7][4][4]$a$3001 [0] $memory\m1.A$rdmux[7][4][4]$a$3001 [0] }, B={ 2'10 $memory\m1.A$rdmux[7][4][4]$b$3002 [1:0] }, Y=$memory\m1.A$rdmux[7][3][2]$a$2971 [3:0]
      New connections: $memory\m1.A$rdmux[7][3][2]$a$2971 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][5]$3003:
      Old ports: A=$memory\m1.A$rdmux[7][4][5]$a$3004, B=$memory\m1.A$rdmux[7][4][5]$b$3005, Y=$memory\m1.A$rdmux[7][3][2]$b$2972
      New ports: A={ 2'01 $memory\m1.A$rdmux[7][4][5]$a$3004 [0] }, B={ 2'10 $memory\m1.A$rdmux[7][4][5]$b$3005 [0] }, Y=$memory\m1.A$rdmux[7][3][2]$b$2972 [2:0]
      New connections: $memory\m1.A$rdmux[7][3][2]$b$2972 [7:3] = 5'00000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][6]$3006:
      Old ports: A=$memory\m1.A$rdmux[7][4][6]$a$3007, B=$memory\m1.A$rdmux[7][4][6]$b$3008, Y=$memory\m1.A$rdmux[7][3][3]$a$2974
      New ports: A={ 2'01 $memory\m1.A$rdmux[7][4][6]$a$3007 [0] }, B={ 2'10 $memory\m1.A$rdmux[7][4][6]$b$3008 [0] }, Y={ $memory\m1.A$rdmux[7][3][3]$a$2974 [3] $memory\m1.A$rdmux[7][3][3]$a$2974 [1:0] }
      New connections: { $memory\m1.A$rdmux[7][3][3]$a$2974 [7:4] $memory\m1.A$rdmux[7][3][3]$a$2974 [2] } = { 4'0000 $memory\m1.A$rdmux[7][3][3]$a$2974 [1] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][7]$3009:
      Old ports: A=$memory\m1.A$rdmux[7][4][7]$a$3010, B=$memory\m1.A$rdmux[7][4][7]$b$3011, Y=$memory\m1.A$rdmux[7][3][3]$b$2975
      New ports: A={ 3'101 $memory\m1.A$rdmux[7][4][7]$a$3010 [0] }, B={ 1'0 $memory\m1.A$rdmux[7][4][7]$b$3011 [2] $memory\m1.A$rdmux[7][4][7]$b$3011 [0] $memory\m1.A$rdmux[7][4][7]$b$3011 [0] }, Y=$memory\m1.A$rdmux[7][3][3]$b$2975 [3:0]
      New connections: $memory\m1.A$rdmux[7][3][3]$b$2975 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][8]$3012:
      Old ports: A=$memory\m1.A$rdmux[7][4][8]$a$3013, B=$memory\m1.A$rdmux[7][4][8]$b$3014, Y=$memory\m1.A$rdmux[7][3][4]$a$2977
      New ports: A={ 2'01 $memory\m1.A$rdmux[7][4][8]$a$3013 [1:0] }, B={ $memory\m1.A$rdmux[7][4][8]$b$3014 [3] $memory\m1.A$rdmux[7][4][8]$b$3014 [0] $memory\m1.A$rdmux[7][4][8]$b$3014 [0] $memory\m1.A$rdmux[7][4][8]$b$3014 [0] }, Y=$memory\m1.A$rdmux[7][3][4]$a$2977 [3:0]
      New connections: $memory\m1.A$rdmux[7][3][4]$a$2977 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][9]$3015:
      Old ports: A=$memory\m1.A$rdmux[7][4][9]$a$3016, B=$memory\m1.A$rdmux[7][4][9]$b$3017, Y=$memory\m1.A$rdmux[7][3][4]$b$2978
      New ports: A={ 1'0 $memory\m1.A$rdmux[7][4][9]$a$3016 [1:0] }, B={ $memory\m1.A$rdmux[7][4][9]$b$3017 [2] $memory\m1.A$rdmux[7][4][9]$b$3017 [0] $memory\m1.A$rdmux[7][4][9]$b$3017 [0] }, Y=$memory\m1.A$rdmux[7][3][4]$b$2978 [2:0]
      New connections: $memory\m1.A$rdmux[7][3][4]$b$2978 [7:3] = 5'00001
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][2][0]$3476:
      Old ports: A=$memory\m1.B$rdmux[7][2][0]$a$3477, B=$memory\m1.B$rdmux[7][2][0]$b$3478, Y=$memory\m1.B$rdmux[7][1][0]$a$3471
      New ports: A={ 1'0 $memory\m1.B$rdmux[7][2][0]$a$3477 [0] }, B={ 1'1 $memory\m1.B$rdmux[7][2][0]$b$3478 [0] }, Y=$memory\m1.B$rdmux[7][1][0]$a$3471 [1:0]
      New connections: $memory\m1.B$rdmux[7][1][0]$a$3471 [7:2] = 6'000000
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][2][1]$3479:
      Old ports: A=$memory\m1.B$rdmux[7][2][1]$a$3480, B=$memory\m1.B$rdmux[7][2][1]$b$3481, Y=$memory\m1.B$rdmux[7][1][0]$b$3472
      New ports: A={ 1'0 $memory\m1.B$rdmux[7][2][1]$a$3480 [0] }, B={ 1'1 $memory\m1.B$rdmux[7][2][1]$b$3481 [0] }, Y=$memory\m1.B$rdmux[7][1][0]$b$3472 [1:0]
      New connections: $memory\m1.B$rdmux[7][1][0]$b$3472 [7:2] = 6'000001
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][2][2]$3482:
      Old ports: A=$memory\m1.B$rdmux[7][2][2]$a$3483, B=8'x, Y=$memory\m1.B$rdmux[7][1][1]$a$3474
      New ports: A={ 2'10 $memory\m1.B$rdmux[7][2][2]$a$3483 [0] }, B=3'x, Y={ $memory\m1.B$rdmux[7][1][1]$a$3474 [3] $memory\m1.B$rdmux[7][1][1]$a$3474 [1:0] }
      New connections: { $memory\m1.B$rdmux[7][1][1]$a$3474 [7:4] $memory\m1.B$rdmux[7][1][1]$a$3474 [2] } = { $memory\m1.B$rdmux[7][1][1]$a$3474 [1] $memory\m1.B$rdmux[7][1][1]$a$3474 [1] $memory\m1.B$rdmux[7][1][1]$a$3474 [1] $memory\m1.B$rdmux[7][1][1]$a$3474 [1] $memory\m1.B$rdmux[7][1][1]$a$3474 [1] }
  Optimizing cells in module \top.
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][2][0]$1629:
      Old ports: A=$memory\m1.A$rdmux[0][2][0]$a$1630, B=$memory\m1.A$rdmux[0][2][0]$b$1631, Y=$memory\m1.A$rdmux[0][1][0]$a$1624
      New ports: A={ 1'0 $memory\m1.A$rdmux[0][2][0]$a$1630 [2:1] 1'0 }, B=$memory\m1.A$rdmux[0][2][0]$b$1631 [3:0], Y=$memory\m1.A$rdmux[0][1][0]$a$1624 [3:0]
      New connections: $memory\m1.A$rdmux[0][1][0]$a$1624 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][2][1]$1632:
      Old ports: A=$memory\m1.A$rdmux[0][2][1]$a$1633, B=$memory\m1.A$rdmux[0][2][1]$b$1634, Y=$memory\m1.A$rdmux[0][1][0]$b$1625
      New ports: A=$memory\m1.A$rdmux[0][2][1]$a$1633 [3:0], B=$memory\m1.A$rdmux[0][2][1]$b$1634 [3:0], Y=$memory\m1.A$rdmux[0][1][0]$b$1625 [3:0]
      New connections: $memory\m1.A$rdmux[0][1][0]$b$1625 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][2][2]$1635:
      Old ports: A=$memory\m1.A$rdmux[0][2][2]$a$1636, B=8'x, Y=$memory\m1.A$rdmux[0][1][1]$a$1627
      New ports: A={ 1'0 $memory\m1.A$rdmux[0][2][2]$a$1636 [3:1] 1'1 }, B=5'x, Y=$memory\m1.A$rdmux[0][1][1]$a$1627 [4:0]
      New connections: $memory\m1.A$rdmux[0][1][1]$a$1627 [7:5] = { $memory\m1.A$rdmux[0][1][1]$a$1627 [4] $memory\m1.A$rdmux[0][1][1]$a$1627 [4] $memory\m1.A$rdmux[0][1][1]$a$1627 [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][2][0]$1818:
      Old ports: A=$memory\m1.A$rdmux[1][2][0]$a$1819, B=$memory\m1.A$rdmux[1][2][0]$b$1820, Y=$memory\m1.A$rdmux[1][1][0]$a$1813
      New ports: A={ 1'0 $memory\m1.A$rdmux[1][2][0]$a$1819 [2:1] 1'1 }, B={ $memory\m1.A$rdmux[1][2][0]$b$1820 [0] $memory\m1.A$rdmux[1][2][0]$b$1820 [2:0] }, Y=$memory\m1.A$rdmux[1][1][0]$a$1813 [3:0]
      New connections: $memory\m1.A$rdmux[1][1][0]$a$1813 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][2][1]$1821:
      Old ports: A=$memory\m1.A$rdmux[1][2][1]$a$1822, B=$memory\m1.A$rdmux[1][2][1]$b$1823, Y=$memory\m1.A$rdmux[1][1][0]$b$1814
      New ports: A=$memory\m1.A$rdmux[1][2][1]$a$1822 [3:0], B=$memory\m1.A$rdmux[1][2][1]$b$1823 [3:0], Y=$memory\m1.A$rdmux[1][1][0]$b$1814 [3:0]
      New connections: $memory\m1.A$rdmux[1][1][0]$b$1814 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][2][2]$1824:
      Old ports: A=$memory\m1.A$rdmux[1][2][2]$a$1825, B=8'x, Y=$memory\m1.A$rdmux[1][1][1]$a$1816
      New ports: A={ $memory\m1.A$rdmux[1][2][2]$a$1825 [3:1] 1'0 }, B=4'x, Y=$memory\m1.A$rdmux[1][1][1]$a$1816 [3:0]
      New connections: $memory\m1.A$rdmux[1][1][1]$a$1816 [7:4] = { $memory\m1.A$rdmux[1][1][1]$a$1816 [0] $memory\m1.A$rdmux[1][1][1]$a$1816 [0] $memory\m1.A$rdmux[1][1][1]$a$1816 [0] $memory\m1.A$rdmux[1][1][1]$a$1816 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][2][0]$2007:
      Old ports: A=$memory\m1.A$rdmux[2][2][0]$a$2008, B=$memory\m1.A$rdmux[2][2][0]$b$2009, Y=$memory\m1.A$rdmux[2][1][0]$a$2002
      New ports: A={ 1'0 $memory\m1.A$rdmux[2][2][0]$a$2008 [2:1] 1'0 }, B=$memory\m1.A$rdmux[2][2][0]$b$2009 [3:0], Y=$memory\m1.A$rdmux[2][1][0]$a$2002 [3:0]
      New connections: $memory\m1.A$rdmux[2][1][0]$a$2002 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][2][1]$2010:
      Old ports: A=$memory\m1.A$rdmux[2][2][1]$a$2011, B=$memory\m1.A$rdmux[2][2][1]$b$2012, Y=$memory\m1.A$rdmux[2][1][0]$b$2003
      New ports: A=$memory\m1.A$rdmux[2][2][1]$a$2011 [3:0], B=$memory\m1.A$rdmux[2][2][1]$b$2012 [3:0], Y=$memory\m1.A$rdmux[2][1][0]$b$2003 [3:0]
      New connections: $memory\m1.A$rdmux[2][1][0]$b$2003 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][2][2]$2013:
      Old ports: A=$memory\m1.A$rdmux[2][2][2]$a$2014, B=8'x, Y=$memory\m1.A$rdmux[2][1][1]$a$2005
      New ports: A={ 1'0 $memory\m1.A$rdmux[2][2][2]$a$2014 [3:1] 1'1 }, B=5'x, Y=$memory\m1.A$rdmux[2][1][1]$a$2005 [4:0]
      New connections: $memory\m1.A$rdmux[2][1][1]$a$2005 [7:5] = { $memory\m1.A$rdmux[2][1][1]$a$2005 [4] $memory\m1.A$rdmux[2][1][1]$a$2005 [4] $memory\m1.A$rdmux[2][1][1]$a$2005 [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][2][0]$2196:
      Old ports: A=$memory\m1.A$rdmux[3][2][0]$a$2197, B=$memory\m1.A$rdmux[3][2][0]$b$2198, Y=$memory\m1.A$rdmux[3][1][0]$a$2191
      New ports: A={ 1'0 $memory\m1.A$rdmux[3][2][0]$a$2197 [2:1] 1'1 }, B={ $memory\m1.A$rdmux[3][2][0]$b$2198 [0] $memory\m1.A$rdmux[3][2][0]$b$2198 [2:0] }, Y=$memory\m1.A$rdmux[3][1][0]$a$2191 [3:0]
      New connections: $memory\m1.A$rdmux[3][1][0]$a$2191 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][2][1]$2199:
      Old ports: A=$memory\m1.A$rdmux[3][2][1]$a$2200, B=$memory\m1.A$rdmux[3][2][1]$b$2201, Y=$memory\m1.A$rdmux[3][1][0]$b$2192
      New ports: A=$memory\m1.A$rdmux[3][2][1]$a$2200 [3:0], B=$memory\m1.A$rdmux[3][2][1]$b$2201 [3:0], Y=$memory\m1.A$rdmux[3][1][0]$b$2192 [3:0]
      New connections: $memory\m1.A$rdmux[3][1][0]$b$2192 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][2][2]$2202:
      Old ports: A=$memory\m1.A$rdmux[3][2][2]$a$2203, B=8'x, Y=$memory\m1.A$rdmux[3][1][1]$a$2194
      New ports: A={ $memory\m1.A$rdmux[3][2][2]$a$2203 [3:1] 1'0 }, B=4'x, Y=$memory\m1.A$rdmux[3][1][1]$a$2194 [3:0]
      New connections: $memory\m1.A$rdmux[3][1][1]$a$2194 [7:4] = { $memory\m1.A$rdmux[3][1][1]$a$2194 [0] $memory\m1.A$rdmux[3][1][1]$a$2194 [0] $memory\m1.A$rdmux[3][1][1]$a$2194 [0] $memory\m1.A$rdmux[3][1][1]$a$2194 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][2][0]$2385:
      Old ports: A=$memory\m1.A$rdmux[4][2][0]$a$2386, B=$memory\m1.A$rdmux[4][2][0]$b$2387, Y=$memory\m1.A$rdmux[4][1][0]$a$2380
      New ports: A={ 1'0 $memory\m1.A$rdmux[4][2][0]$a$2386 [2:1] 1'0 }, B=$memory\m1.A$rdmux[4][2][0]$b$2387 [3:0], Y=$memory\m1.A$rdmux[4][1][0]$a$2380 [3:0]
      New connections: $memory\m1.A$rdmux[4][1][0]$a$2380 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][2][1]$2388:
      Old ports: A=$memory\m1.A$rdmux[4][2][1]$a$2389, B=$memory\m1.A$rdmux[4][2][1]$b$2390, Y=$memory\m1.A$rdmux[4][1][0]$b$2381
      New ports: A=$memory\m1.A$rdmux[4][2][1]$a$2389 [3:0], B=$memory\m1.A$rdmux[4][2][1]$b$2390 [3:0], Y=$memory\m1.A$rdmux[4][1][0]$b$2381 [3:0]
      New connections: $memory\m1.A$rdmux[4][1][0]$b$2381 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][2][2]$2391:
      Old ports: A=$memory\m1.A$rdmux[4][2][2]$a$2392, B=8'x, Y=$memory\m1.A$rdmux[4][1][1]$a$2383
      New ports: A={ 1'0 $memory\m1.A$rdmux[4][2][2]$a$2392 [3:1] 1'1 }, B=5'x, Y=$memory\m1.A$rdmux[4][1][1]$a$2383 [4:0]
      New connections: $memory\m1.A$rdmux[4][1][1]$a$2383 [7:5] = { $memory\m1.A$rdmux[4][1][1]$a$2383 [4] $memory\m1.A$rdmux[4][1][1]$a$2383 [4] $memory\m1.A$rdmux[4][1][1]$a$2383 [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][2][0]$2574:
      Old ports: A=$memory\m1.A$rdmux[5][2][0]$a$2575, B=$memory\m1.A$rdmux[5][2][0]$b$2576, Y=$memory\m1.A$rdmux[5][1][0]$a$2569
      New ports: A={ 1'0 $memory\m1.A$rdmux[5][2][0]$a$2575 [2:1] 1'1 }, B={ $memory\m1.A$rdmux[5][2][0]$b$2576 [0] $memory\m1.A$rdmux[5][2][0]$b$2576 [2:0] }, Y=$memory\m1.A$rdmux[5][1][0]$a$2569 [3:0]
      New connections: $memory\m1.A$rdmux[5][1][0]$a$2569 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][2][1]$2577:
      Old ports: A=$memory\m1.A$rdmux[5][2][1]$a$2578, B=$memory\m1.A$rdmux[5][2][1]$b$2579, Y=$memory\m1.A$rdmux[5][1][0]$b$2570
      New ports: A=$memory\m1.A$rdmux[5][2][1]$a$2578 [3:0], B=$memory\m1.A$rdmux[5][2][1]$b$2579 [3:0], Y=$memory\m1.A$rdmux[5][1][0]$b$2570 [3:0]
      New connections: $memory\m1.A$rdmux[5][1][0]$b$2570 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][2][2]$2580:
      Old ports: A=$memory\m1.A$rdmux[5][2][2]$a$2581, B=8'x, Y=$memory\m1.A$rdmux[5][1][1]$a$2572
      New ports: A={ $memory\m1.A$rdmux[5][2][2]$a$2581 [3:1] 1'0 }, B=4'x, Y=$memory\m1.A$rdmux[5][1][1]$a$2572 [3:0]
      New connections: $memory\m1.A$rdmux[5][1][1]$a$2572 [7:4] = { $memory\m1.A$rdmux[5][1][1]$a$2572 [0] $memory\m1.A$rdmux[5][1][1]$a$2572 [0] $memory\m1.A$rdmux[5][1][1]$a$2572 [0] $memory\m1.A$rdmux[5][1][1]$a$2572 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][2][0]$2763:
      Old ports: A=$memory\m1.A$rdmux[6][2][0]$a$2764, B=$memory\m1.A$rdmux[6][2][0]$b$2765, Y=$memory\m1.A$rdmux[6][1][0]$a$2758
      New ports: A={ 1'0 $memory\m1.A$rdmux[6][2][0]$a$2764 [2:1] 1'0 }, B=$memory\m1.A$rdmux[6][2][0]$b$2765 [3:0], Y=$memory\m1.A$rdmux[6][1][0]$a$2758 [3:0]
      New connections: $memory\m1.A$rdmux[6][1][0]$a$2758 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][2][1]$2766:
      Old ports: A=$memory\m1.A$rdmux[6][2][1]$a$2767, B=$memory\m1.A$rdmux[6][2][1]$b$2768, Y=$memory\m1.A$rdmux[6][1][0]$b$2759
      New ports: A=$memory\m1.A$rdmux[6][2][1]$a$2767 [3:0], B=$memory\m1.A$rdmux[6][2][1]$b$2768 [3:0], Y=$memory\m1.A$rdmux[6][1][0]$b$2759 [3:0]
      New connections: $memory\m1.A$rdmux[6][1][0]$b$2759 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][2][2]$2769:
      Old ports: A=$memory\m1.A$rdmux[6][2][2]$a$2770, B=8'x, Y=$memory\m1.A$rdmux[6][1][1]$a$2761
      New ports: A={ 1'0 $memory\m1.A$rdmux[6][2][2]$a$2770 [3:1] 1'1 }, B=5'x, Y=$memory\m1.A$rdmux[6][1][1]$a$2761 [4:0]
      New connections: $memory\m1.A$rdmux[6][1][1]$a$2761 [7:5] = { $memory\m1.A$rdmux[6][1][1]$a$2761 [4] $memory\m1.A$rdmux[6][1][1]$a$2761 [4] $memory\m1.A$rdmux[6][1][1]$a$2761 [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][3][0]$2964:
      Old ports: A=$memory\m1.A$rdmux[7][3][0]$a$2965, B=$memory\m1.A$rdmux[7][3][0]$b$2966, Y=$memory\m1.A$rdmux[7][2][0]$a$2953
      New ports: A={ 1'0 $memory\m1.A$rdmux[7][3][0]$a$2965 [1:0] }, B={ 1'1 $memory\m1.A$rdmux[7][3][0]$b$2966 [1:0] }, Y=$memory\m1.A$rdmux[7][2][0]$a$2953 [2:0]
      New connections: $memory\m1.A$rdmux[7][2][0]$a$2953 [7:3] = 5'00000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][3][1]$2967:
      Old ports: A=$memory\m1.A$rdmux[7][3][1]$a$2968, B=$memory\m1.A$rdmux[7][3][1]$b$2969, Y=$memory\m1.A$rdmux[7][2][0]$b$2954
      New ports: A={ $memory\m1.A$rdmux[7][3][1]$a$2968 [3] 1'0 $memory\m1.A$rdmux[7][3][1]$a$2968 [1:0] }, B={ 1'0 $memory\m1.A$rdmux[7][3][1]$b$2969 [2:0] }, Y=$memory\m1.A$rdmux[7][2][0]$b$2954 [3:0]
      New connections: $memory\m1.A$rdmux[7][2][0]$b$2954 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][3][2]$2970:
      Old ports: A=$memory\m1.A$rdmux[7][3][2]$a$2971, B=$memory\m1.A$rdmux[7][3][2]$b$2972, Y=$memory\m1.A$rdmux[7][2][1]$a$2956
      New ports: A=$memory\m1.A$rdmux[7][3][2]$a$2971 [3:0], B={ 1'0 $memory\m1.A$rdmux[7][3][2]$b$2972 [2:0] }, Y=$memory\m1.A$rdmux[7][2][1]$a$2956 [3:0]
      New connections: $memory\m1.A$rdmux[7][2][1]$a$2956 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][3][3]$2973:
      Old ports: A=$memory\m1.A$rdmux[7][3][3]$a$2974, B=$memory\m1.A$rdmux[7][3][3]$b$2975, Y=$memory\m1.A$rdmux[7][2][1]$b$2957
      New ports: A={ $memory\m1.A$rdmux[7][3][3]$a$2974 [3] $memory\m1.A$rdmux[7][3][3]$a$2974 [1] $memory\m1.A$rdmux[7][3][3]$a$2974 [1:0] }, B=$memory\m1.A$rdmux[7][3][3]$b$2975 [3:0], Y=$memory\m1.A$rdmux[7][2][1]$b$2957 [3:0]
      New connections: $memory\m1.A$rdmux[7][2][1]$b$2957 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][3][4]$2976:
      Old ports: A=$memory\m1.A$rdmux[7][3][4]$a$2977, B=$memory\m1.A$rdmux[7][3][4]$b$2978, Y=$memory\m1.A$rdmux[7][2][2]$a$2959
      New ports: A=$memory\m1.A$rdmux[7][3][4]$a$2977 [3:0], B={ 1'1 $memory\m1.A$rdmux[7][3][4]$b$2978 [2:0] }, Y=$memory\m1.A$rdmux[7][2][2]$a$2959 [3:0]
      New connections: $memory\m1.A$rdmux[7][2][2]$a$2959 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][1][0]$3470:
      Old ports: A=$memory\m1.B$rdmux[7][1][0]$a$3471, B=$memory\m1.B$rdmux[7][1][0]$b$3472, Y=$memory\m1.B$rdmux[7][0][0]$a$3468
      New ports: A={ 1'0 $memory\m1.B$rdmux[7][1][0]$a$3471 [1:0] }, B={ 1'1 $memory\m1.B$rdmux[7][1][0]$b$3472 [1:0] }, Y=$memory\m1.B$rdmux[7][0][0]$a$3468 [2:0]
      New connections: $memory\m1.B$rdmux[7][0][0]$a$3468 [7:3] = 5'00000
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][1][1]$3473:
      Old ports: A=$memory\m1.B$rdmux[7][1][1]$a$3474, B=8'x, Y=$memory\m1.B$rdmux[7][0][0]$b$3469
      New ports: A={ $memory\m1.B$rdmux[7][1][1]$a$3474 [3] $memory\m1.B$rdmux[7][1][1]$a$3474 [1:0] }, B=3'x, Y={ $memory\m1.B$rdmux[7][0][0]$b$3469 [3] $memory\m1.B$rdmux[7][0][0]$b$3469 [1:0] }
      New connections: { $memory\m1.B$rdmux[7][0][0]$b$3469 [7:4] $memory\m1.B$rdmux[7][0][0]$b$3469 [2] } = { $memory\m1.B$rdmux[7][0][0]$b$3469 [1] $memory\m1.B$rdmux[7][0][0]$b$3469 [1] $memory\m1.B$rdmux[7][0][0]$b$3469 [1] $memory\m1.B$rdmux[7][0][0]$b$3469 [1] $memory\m1.B$rdmux[7][0][0]$b$3469 [1] }
  Optimizing cells in module \top.
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][1][0]$1623:
      Old ports: A=$memory\m1.A$rdmux[0][1][0]$a$1624, B=$memory\m1.A$rdmux[0][1][0]$b$1625, Y=$memory\m1.A$rdmux[0][0][0]$a$1621
      New ports: A=$memory\m1.A$rdmux[0][1][0]$a$1624 [3:0], B=$memory\m1.A$rdmux[0][1][0]$b$1625 [3:0], Y=$memory\m1.A$rdmux[0][0][0]$a$1621 [3:0]
      New connections: $memory\m1.A$rdmux[0][0][0]$a$1621 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][1][1]$1626:
      Old ports: A=$memory\m1.A$rdmux[0][1][1]$a$1627, B=8'x, Y=$memory\m1.A$rdmux[0][0][0]$b$1622
      New ports: A=$memory\m1.A$rdmux[0][1][1]$a$1627 [4:0], B=5'x, Y=$memory\m1.A$rdmux[0][0][0]$b$1622 [4:0]
      New connections: $memory\m1.A$rdmux[0][0][0]$b$1622 [7:5] = { $memory\m1.A$rdmux[0][0][0]$b$1622 [4] $memory\m1.A$rdmux[0][0][0]$b$1622 [4] $memory\m1.A$rdmux[0][0][0]$b$1622 [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][1][0]$1812:
      Old ports: A=$memory\m1.A$rdmux[1][1][0]$a$1813, B=$memory\m1.A$rdmux[1][1][0]$b$1814, Y=$memory\m1.A$rdmux[1][0][0]$a$1810
      New ports: A=$memory\m1.A$rdmux[1][1][0]$a$1813 [3:0], B=$memory\m1.A$rdmux[1][1][0]$b$1814 [3:0], Y=$memory\m1.A$rdmux[1][0][0]$a$1810 [3:0]
      New connections: $memory\m1.A$rdmux[1][0][0]$a$1810 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][1][1]$1815:
      Old ports: A=$memory\m1.A$rdmux[1][1][1]$a$1816, B=8'x, Y=$memory\m1.A$rdmux[1][0][0]$b$1811
      New ports: A=$memory\m1.A$rdmux[1][1][1]$a$1816 [3:0], B=4'x, Y=$memory\m1.A$rdmux[1][0][0]$b$1811 [3:0]
      New connections: $memory\m1.A$rdmux[1][0][0]$b$1811 [7:4] = { $memory\m1.A$rdmux[1][0][0]$b$1811 [0] $memory\m1.A$rdmux[1][0][0]$b$1811 [0] $memory\m1.A$rdmux[1][0][0]$b$1811 [0] $memory\m1.A$rdmux[1][0][0]$b$1811 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][1][0]$2001:
      Old ports: A=$memory\m1.A$rdmux[2][1][0]$a$2002, B=$memory\m1.A$rdmux[2][1][0]$b$2003, Y=$memory\m1.A$rdmux[2][0][0]$a$1999
      New ports: A=$memory\m1.A$rdmux[2][1][0]$a$2002 [3:0], B=$memory\m1.A$rdmux[2][1][0]$b$2003 [3:0], Y=$memory\m1.A$rdmux[2][0][0]$a$1999 [3:0]
      New connections: $memory\m1.A$rdmux[2][0][0]$a$1999 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][1][1]$2004:
      Old ports: A=$memory\m1.A$rdmux[2][1][1]$a$2005, B=8'x, Y=$memory\m1.A$rdmux[2][0][0]$b$2000
      New ports: A=$memory\m1.A$rdmux[2][1][1]$a$2005 [4:0], B=5'x, Y=$memory\m1.A$rdmux[2][0][0]$b$2000 [4:0]
      New connections: $memory\m1.A$rdmux[2][0][0]$b$2000 [7:5] = { $memory\m1.A$rdmux[2][0][0]$b$2000 [4] $memory\m1.A$rdmux[2][0][0]$b$2000 [4] $memory\m1.A$rdmux[2][0][0]$b$2000 [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][1][0]$2190:
      Old ports: A=$memory\m1.A$rdmux[3][1][0]$a$2191, B=$memory\m1.A$rdmux[3][1][0]$b$2192, Y=$memory\m1.A$rdmux[3][0][0]$a$2188
      New ports: A=$memory\m1.A$rdmux[3][1][0]$a$2191 [3:0], B=$memory\m1.A$rdmux[3][1][0]$b$2192 [3:0], Y=$memory\m1.A$rdmux[3][0][0]$a$2188 [3:0]
      New connections: $memory\m1.A$rdmux[3][0][0]$a$2188 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][1][1]$2193:
      Old ports: A=$memory\m1.A$rdmux[3][1][1]$a$2194, B=8'x, Y=$memory\m1.A$rdmux[3][0][0]$b$2189
      New ports: A=$memory\m1.A$rdmux[3][1][1]$a$2194 [3:0], B=4'x, Y=$memory\m1.A$rdmux[3][0][0]$b$2189 [3:0]
      New connections: $memory\m1.A$rdmux[3][0][0]$b$2189 [7:4] = { $memory\m1.A$rdmux[3][0][0]$b$2189 [0] $memory\m1.A$rdmux[3][0][0]$b$2189 [0] $memory\m1.A$rdmux[3][0][0]$b$2189 [0] $memory\m1.A$rdmux[3][0][0]$b$2189 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][1][0]$2379:
      Old ports: A=$memory\m1.A$rdmux[4][1][0]$a$2380, B=$memory\m1.A$rdmux[4][1][0]$b$2381, Y=$memory\m1.A$rdmux[4][0][0]$a$2377
      New ports: A=$memory\m1.A$rdmux[4][1][0]$a$2380 [3:0], B=$memory\m1.A$rdmux[4][1][0]$b$2381 [3:0], Y=$memory\m1.A$rdmux[4][0][0]$a$2377 [3:0]
      New connections: $memory\m1.A$rdmux[4][0][0]$a$2377 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][1][1]$2382:
      Old ports: A=$memory\m1.A$rdmux[4][1][1]$a$2383, B=8'x, Y=$memory\m1.A$rdmux[4][0][0]$b$2378
      New ports: A=$memory\m1.A$rdmux[4][1][1]$a$2383 [4:0], B=5'x, Y=$memory\m1.A$rdmux[4][0][0]$b$2378 [4:0]
      New connections: $memory\m1.A$rdmux[4][0][0]$b$2378 [7:5] = { $memory\m1.A$rdmux[4][0][0]$b$2378 [4] $memory\m1.A$rdmux[4][0][0]$b$2378 [4] $memory\m1.A$rdmux[4][0][0]$b$2378 [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][1][0]$2568:
      Old ports: A=$memory\m1.A$rdmux[5][1][0]$a$2569, B=$memory\m1.A$rdmux[5][1][0]$b$2570, Y=$memory\m1.A$rdmux[5][0][0]$a$2566
      New ports: A=$memory\m1.A$rdmux[5][1][0]$a$2569 [3:0], B=$memory\m1.A$rdmux[5][1][0]$b$2570 [3:0], Y=$memory\m1.A$rdmux[5][0][0]$a$2566 [3:0]
      New connections: $memory\m1.A$rdmux[5][0][0]$a$2566 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][1][1]$2571:
      Old ports: A=$memory\m1.A$rdmux[5][1][1]$a$2572, B=8'x, Y=$memory\m1.A$rdmux[5][0][0]$b$2567
      New ports: A=$memory\m1.A$rdmux[5][1][1]$a$2572 [3:0], B=4'x, Y=$memory\m1.A$rdmux[5][0][0]$b$2567 [3:0]
      New connections: $memory\m1.A$rdmux[5][0][0]$b$2567 [7:4] = { $memory\m1.A$rdmux[5][0][0]$b$2567 [0] $memory\m1.A$rdmux[5][0][0]$b$2567 [0] $memory\m1.A$rdmux[5][0][0]$b$2567 [0] $memory\m1.A$rdmux[5][0][0]$b$2567 [0] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][1][0]$2757:
      Old ports: A=$memory\m1.A$rdmux[6][1][0]$a$2758, B=$memory\m1.A$rdmux[6][1][0]$b$2759, Y=$memory\m1.A$rdmux[6][0][0]$a$2755
      New ports: A=$memory\m1.A$rdmux[6][1][0]$a$2758 [3:0], B=$memory\m1.A$rdmux[6][1][0]$b$2759 [3:0], Y=$memory\m1.A$rdmux[6][0][0]$a$2755 [3:0]
      New connections: $memory\m1.A$rdmux[6][0][0]$a$2755 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][1][1]$2760:
      Old ports: A=$memory\m1.A$rdmux[6][1][1]$a$2761, B=8'x, Y=$memory\m1.A$rdmux[6][0][0]$b$2756
      New ports: A=$memory\m1.A$rdmux[6][1][1]$a$2761 [4:0], B=5'x, Y=$memory\m1.A$rdmux[6][0][0]$b$2756 [4:0]
      New connections: $memory\m1.A$rdmux[6][0][0]$b$2756 [7:5] = { $memory\m1.A$rdmux[6][0][0]$b$2756 [4] $memory\m1.A$rdmux[6][0][0]$b$2756 [4] $memory\m1.A$rdmux[6][0][0]$b$2756 [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][2][0]$2952:
      Old ports: A=$memory\m1.A$rdmux[7][2][0]$a$2953, B=$memory\m1.A$rdmux[7][2][0]$b$2954, Y=$memory\m1.A$rdmux[7][1][0]$a$2947
      New ports: A={ 1'0 $memory\m1.A$rdmux[7][2][0]$a$2953 [2:0] }, B=$memory\m1.A$rdmux[7][2][0]$b$2954 [3:0], Y=$memory\m1.A$rdmux[7][1][0]$a$2947 [3:0]
      New connections: $memory\m1.A$rdmux[7][1][0]$a$2947 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][2][1]$2955:
      Old ports: A=$memory\m1.A$rdmux[7][2][1]$a$2956, B=$memory\m1.A$rdmux[7][2][1]$b$2957, Y=$memory\m1.A$rdmux[7][1][0]$b$2948
      New ports: A=$memory\m1.A$rdmux[7][2][1]$a$2956 [3:0], B=$memory\m1.A$rdmux[7][2][1]$b$2957 [3:0], Y=$memory\m1.A$rdmux[7][1][0]$b$2948 [3:0]
      New connections: $memory\m1.A$rdmux[7][1][0]$b$2948 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][2][2]$2958:
      Old ports: A=$memory\m1.A$rdmux[7][2][2]$a$2959, B=8'x, Y=$memory\m1.A$rdmux[7][1][1]$a$2950
      New ports: A={ 1'0 $memory\m1.A$rdmux[7][2][2]$a$2959 [3:0] }, B=5'x, Y=$memory\m1.A$rdmux[7][1][1]$a$2950 [4:0]
      New connections: $memory\m1.A$rdmux[7][1][1]$a$2950 [7:5] = { $memory\m1.A$rdmux[7][1][1]$a$2950 [4] $memory\m1.A$rdmux[7][1][1]$a$2950 [4] $memory\m1.A$rdmux[7][1][1]$a$2950 [4] }
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][0][0]$3467:
      Old ports: A=$memory\m1.B$rdmux[7][0][0]$a$3468, B=$memory\m1.B$rdmux[7][0][0]$b$3469, Y=$techmap1334$auto$share.cc:667:make_supercell$1282.B
      New ports: A={ 2'00 $memory\m1.B$rdmux[7][0][0]$a$3468 [2:0] }, B={ $memory\m1.B$rdmux[7][0][0]$b$3469 [1] $memory\m1.B$rdmux[7][0][0]$b$3469 [3] $memory\m1.B$rdmux[7][0][0]$b$3469 [1] $memory\m1.B$rdmux[7][0][0]$b$3469 [1:0] }, Y=$techmap1334$auto$share.cc:667:make_supercell$1282.B [4:0]
      New connections: $techmap1334$auto$share.cc:667:make_supercell$1282.B [7:5] = { $techmap1334$auto$share.cc:667:make_supercell$1282.B [4] $techmap1334$auto$share.cc:667:make_supercell$1282.B [4] $techmap1334$auto$share.cc:667:make_supercell$1282.B [4] }
  Optimizing cells in module \top.
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][0][0]$1620:
      Old ports: A=$memory\m1.A$rdmux[0][0][0]$a$1621, B=$memory\m1.A$rdmux[0][0][0]$b$1622, Y=$techmap1335$flatten\m1.$mul$matmul.v:109$562.A
      New ports: A={ 1'0 $memory\m1.A$rdmux[0][0][0]$a$1621 [3:0] }, B=$memory\m1.A$rdmux[0][0][0]$b$1622 [4:0], Y=$techmap1335$flatten\m1.$mul$matmul.v:109$562.A [4:0]
      New connections: $techmap1335$flatten\m1.$mul$matmul.v:109$562.A [7:5] = { $techmap1335$flatten\m1.$mul$matmul.v:109$562.A [4] $techmap1335$flatten\m1.$mul$matmul.v:109$562.A [4] $techmap1335$flatten\m1.$mul$matmul.v:109$562.A [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][0][0]$1809:
      Old ports: A=$memory\m1.A$rdmux[1][0][0]$a$1810, B=$memory\m1.A$rdmux[1][0][0]$b$1811, Y=$techmap1336$flatten\m1.$mul$matmul.v:109$552.A
      New ports: A={ 1'0 $memory\m1.A$rdmux[1][0][0]$a$1810 [3:0] }, B={ $memory\m1.A$rdmux[1][0][0]$b$1811 [0] $memory\m1.A$rdmux[1][0][0]$b$1811 [3:0] }, Y=$techmap1336$flatten\m1.$mul$matmul.v:109$552.A [4:0]
      New connections: $techmap1336$flatten\m1.$mul$matmul.v:109$552.A [7:5] = { $techmap1336$flatten\m1.$mul$matmul.v:109$552.A [4] $techmap1336$flatten\m1.$mul$matmul.v:109$552.A [4] $techmap1336$flatten\m1.$mul$matmul.v:109$552.A [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][0][0]$1998:
      Old ports: A=$memory\m1.A$rdmux[2][0][0]$a$1999, B=$memory\m1.A$rdmux[2][0][0]$b$2000, Y=$techmap1337$flatten\m1.$mul$matmul.v:109$542.A
      New ports: A={ 1'0 $memory\m1.A$rdmux[2][0][0]$a$1999 [3:0] }, B=$memory\m1.A$rdmux[2][0][0]$b$2000 [4:0], Y=$techmap1337$flatten\m1.$mul$matmul.v:109$542.A [4:0]
      New connections: $techmap1337$flatten\m1.$mul$matmul.v:109$542.A [7:5] = { $techmap1337$flatten\m1.$mul$matmul.v:109$542.A [4] $techmap1337$flatten\m1.$mul$matmul.v:109$542.A [4] $techmap1337$flatten\m1.$mul$matmul.v:109$542.A [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][0][0]$2187:
      Old ports: A=$memory\m1.A$rdmux[3][0][0]$a$2188, B=$memory\m1.A$rdmux[3][0][0]$b$2189, Y=$techmap1338$flatten\m1.$mul$matmul.v:109$532.A
      New ports: A={ 1'0 $memory\m1.A$rdmux[3][0][0]$a$2188 [3:0] }, B={ $memory\m1.A$rdmux[3][0][0]$b$2189 [0] $memory\m1.A$rdmux[3][0][0]$b$2189 [3:0] }, Y=$techmap1338$flatten\m1.$mul$matmul.v:109$532.A [4:0]
      New connections: $techmap1338$flatten\m1.$mul$matmul.v:109$532.A [7:5] = { $techmap1338$flatten\m1.$mul$matmul.v:109$532.A [4] $techmap1338$flatten\m1.$mul$matmul.v:109$532.A [4] $techmap1338$flatten\m1.$mul$matmul.v:109$532.A [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][0][0]$2376:
      Old ports: A=$memory\m1.A$rdmux[4][0][0]$a$2377, B=$memory\m1.A$rdmux[4][0][0]$b$2378, Y=$techmap1339$flatten\m1.$mul$matmul.v:109$522.A
      New ports: A={ 1'0 $memory\m1.A$rdmux[4][0][0]$a$2377 [3:0] }, B=$memory\m1.A$rdmux[4][0][0]$b$2378 [4:0], Y=$techmap1339$flatten\m1.$mul$matmul.v:109$522.A [4:0]
      New connections: $techmap1339$flatten\m1.$mul$matmul.v:109$522.A [7:5] = { $techmap1339$flatten\m1.$mul$matmul.v:109$522.A [4] $techmap1339$flatten\m1.$mul$matmul.v:109$522.A [4] $techmap1339$flatten\m1.$mul$matmul.v:109$522.A [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][0][0]$2565:
      Old ports: A=$memory\m1.A$rdmux[5][0][0]$a$2566, B=$memory\m1.A$rdmux[5][0][0]$b$2567, Y=$techmap1340$flatten\m1.$mul$matmul.v:109$512.A
      New ports: A={ 1'0 $memory\m1.A$rdmux[5][0][0]$a$2566 [3:0] }, B={ $memory\m1.A$rdmux[5][0][0]$b$2567 [0] $memory\m1.A$rdmux[5][0][0]$b$2567 [3:0] }, Y=$techmap1340$flatten\m1.$mul$matmul.v:109$512.A [4:0]
      New connections: $techmap1340$flatten\m1.$mul$matmul.v:109$512.A [7:5] = { $techmap1340$flatten\m1.$mul$matmul.v:109$512.A [4] $techmap1340$flatten\m1.$mul$matmul.v:109$512.A [4] $techmap1340$flatten\m1.$mul$matmul.v:109$512.A [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][0][0]$2754:
      Old ports: A=$memory\m1.A$rdmux[6][0][0]$a$2755, B=$memory\m1.A$rdmux[6][0][0]$b$2756, Y=$techmap1341$flatten\m1.$mul$matmul.v:109$502.A
      New ports: A={ 1'0 $memory\m1.A$rdmux[6][0][0]$a$2755 [3:0] }, B=$memory\m1.A$rdmux[6][0][0]$b$2756 [4:0], Y=$techmap1341$flatten\m1.$mul$matmul.v:109$502.A [4:0]
      New connections: $techmap1341$flatten\m1.$mul$matmul.v:109$502.A [7:5] = { $techmap1341$flatten\m1.$mul$matmul.v:109$502.A [4] $techmap1341$flatten\m1.$mul$matmul.v:109$502.A [4] $techmap1341$flatten\m1.$mul$matmul.v:109$502.A [4] }
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][1][0]$2946:
      Old ports: A=$memory\m1.A$rdmux[7][1][0]$a$2947, B=$memory\m1.A$rdmux[7][1][0]$b$2948, Y=$memory\m1.A$rdmux[7][0][0]$a$2944
      New ports: A=$memory\m1.A$rdmux[7][1][0]$a$2947 [3:0], B=$memory\m1.A$rdmux[7][1][0]$b$2948 [3:0], Y=$memory\m1.A$rdmux[7][0][0]$a$2944 [3:0]
      New connections: $memory\m1.A$rdmux[7][0][0]$a$2944 [7:4] = 4'0000
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][1][1]$2949:
      Old ports: A=$memory\m1.A$rdmux[7][1][1]$a$2950, B=8'x, Y=$memory\m1.A$rdmux[7][0][0]$b$2945
      New ports: A=$memory\m1.A$rdmux[7][1][1]$a$2950 [4:0], B=5'x, Y=$memory\m1.A$rdmux[7][0][0]$b$2945 [4:0]
      New connections: $memory\m1.A$rdmux[7][0][0]$b$2945 [7:5] = { $memory\m1.A$rdmux[7][0][0]$b$2945 [4] $memory\m1.A$rdmux[7][0][0]$b$2945 [4] $memory\m1.A$rdmux[7][0][0]$b$2945 [4] }
  Optimizing cells in module \top.
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][0][0]$2943:
      Old ports: A=$memory\m1.A$rdmux[7][0][0]$a$2944, B=$memory\m1.A$rdmux[7][0][0]$b$2945, Y=$techmap1334$auto$share.cc:667:make_supercell$1282.A
      New ports: A={ 1'0 $memory\m1.A$rdmux[7][0][0]$a$2944 [3:0] }, B=$memory\m1.A$rdmux[7][0][0]$b$2945 [4:0], Y=$techmap1334$auto$share.cc:667:make_supercell$1282.A [4:0]
      New connections: $techmap1334$auto$share.cc:667:make_supercell$1282.A [7:5] = { $techmap1334$auto$share.cc:667:make_supercell$1282.A [4] $techmap1334$auto$share.cc:667:make_supercell$1282.A [4] $techmap1334$auto$share.cc:667:make_supercell$1282.A [4] }
  Optimizing cells in module \top.
Performed a total of 186 changes.

3.36.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
<suppressed ~216 debug messages>
Removed a total of 72 cells.

3.36.13. Executing OPT_DFF pass (perform DFF optimizations).

3.36.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 0 unused cells and 82 unused wires.
<suppressed ~1 debug messages>

3.36.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.36.16. Rerunning OPT passes. (Maybe there is more to do..)

3.36.17. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~43 debug messages>

3.36.18. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][3][0]$1641:
      Old ports: A={ 1'0 $memory\m1.A$rdmux[0][3][0]$a$1642 [1] }, B={ 1'1 $memory\m1.A$rdmux[0][3][0]$a$1642 [1] }, Y=$memory\m1.A$rdmux[0][2][0]$a$1630 [2:1]
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[0][2][0]$a$1630 [2]
      New connections: $memory\m1.A$rdmux[0][2][0]$a$1630 [1] = $memory\m1.A$rdmux[0][3][0]$a$1642 [1]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][3][2]$1647:
      Old ports: A={ $memory\m1.A$rdmux[0][3][1]$b$1646 [2:1] $memory\m1.A$rdmux[0][3][1]$b$1646 [1] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[0][3][1]$b$1646 [2:1] 1'0 }, Y=$memory\m1.A$rdmux[0][2][1]$a$1633 [3:0]
      New ports: A={ $memory\m1.A$rdmux[0][3][1]$b$1646 [2:1] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[0][3][1]$b$1646 [2] 1'0 }, Y={ $memory\m1.A$rdmux[0][2][1]$a$1633 [3:2] $memory\m1.A$rdmux[0][2][1]$a$1633 [0] }
      New connections: $memory\m1.A$rdmux[0][2][1]$a$1633 [1] = $memory\m1.A$rdmux[0][3][1]$b$1646 [1]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[0][3][4]$1653:
      Old ports: A={ 2'01 $memory\m1.A$rdmux[0][3][0]$a$1642 [1] }, B={ 2'10 $memory\m1.A$rdmux[0][3][0]$a$1642 [1] }, Y=$memory\m1.A$rdmux[0][2][2]$a$1636 [3:1]
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[0][2][2]$a$1636 [3:2]
      New connections: $memory\m1.A$rdmux[0][2][2]$a$1636 [1] = $memory\m1.A$rdmux[0][3][0]$a$1642 [1]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][3][0]$1830:
      Old ports: A={ 1'0 $memory\m1.A$rdmux[1][3][0]$a$1831 [1] }, B={ 1'1 $memory\m1.A$rdmux[1][3][0]$a$1831 [1] }, Y=$memory\m1.A$rdmux[1][2][0]$a$1819 [2:1]
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[1][2][0]$a$1819 [2]
      New connections: $memory\m1.A$rdmux[1][2][0]$a$1819 [1] = $memory\m1.A$rdmux[1][3][0]$a$1831 [1]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][3][3]$1839:
      Old ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] 1'1 }, B={ $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] }, Y=$memory\m1.A$rdmux[1][2][1]$b$1823 [3:0]
      New ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] 1'1 }, B={ $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] }, Y={ $memory\m1.A$rdmux[1][2][1]$b$1823 [3:2] $memory\m1.A$rdmux[1][2][1]$b$1823 [0] }
      New connections: $memory\m1.A$rdmux[1][2][1]$b$1823 [1] = $memory\m1.A$rdmux[1][3][1]$a$1834 [3]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[1][3][4]$1842:
      Old ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] }, B={ 1'1 $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] }, Y=$memory\m1.A$rdmux[1][2][2]$a$1825 [3:1]
      New ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] }, B={ 1'1 $memory\m1.A$rdmux[1][3][1]$a$1834 [1] }, Y=$memory\m1.A$rdmux[1][2][2]$a$1825 [3:2]
      New connections: $memory\m1.A$rdmux[1][2][2]$a$1825 [1] = $memory\m1.A$rdmux[1][3][1]$a$1834 [3]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][3][2]$2025:
      Old ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] 1'0 }, Y=$memory\m1.A$rdmux[2][2][1]$a$2011 [3:0]
      New ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[1][3][1]$a$1834 [1] 1'0 }, Y={ $memory\m1.A$rdmux[2][2][1]$a$2011 [3:2] $memory\m1.A$rdmux[2][2][1]$a$2011 [0] }
      New connections: $memory\m1.A$rdmux[2][2][1]$a$2011 [1] = $memory\m1.A$rdmux[1][3][1]$a$1834 [3]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[2][3][4]$2031:
      Old ports: A={ 2'01 $memory\m1.A$rdmux[1][3][0]$a$1831 [1] }, B={ 2'10 $memory\m1.A$rdmux[1][3][0]$a$1831 [1] }, Y=$memory\m1.A$rdmux[2][2][2]$a$2014 [3:1]
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[2][2][2]$a$2014 [3:2]
      New connections: $memory\m1.A$rdmux[2][2][2]$a$2014 [1] = $memory\m1.A$rdmux[1][3][0]$a$1831 [1]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][3][0]$2208:
      Old ports: A={ 1'0 $memory\m1.A$rdmux[3][3][0]$a$2209 [1] }, B={ 1'1 $memory\m1.A$rdmux[3][3][0]$a$2209 [1] }, Y=$memory\m1.A$rdmux[3][2][0]$a$2197 [2:1]
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[3][2][0]$a$2197 [2]
      New connections: $memory\m1.A$rdmux[3][2][0]$a$2197 [1] = $memory\m1.A$rdmux[3][3][0]$a$2209 [1]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][3][3]$2217:
      Old ports: A={ $memory\m1.A$rdmux[3][3][1]$a$2212 [1] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] 1'1 }, B={ $memory\m1.A$rdmux[3][3][1]$a$2212 [3] $memory\m1.A$rdmux[3][3][1]$a$2212 [1] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] }, Y=$memory\m1.A$rdmux[3][2][1]$b$2201 [3:0]
      New ports: A={ $memory\m1.A$rdmux[3][3][1]$a$2212 [1] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] 1'1 }, B={ $memory\m1.A$rdmux[3][3][1]$a$2212 [3] $memory\m1.A$rdmux[3][3][1]$a$2212 [1] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] }, Y={ $memory\m1.A$rdmux[3][2][1]$b$2201 [3:2] $memory\m1.A$rdmux[3][2][1]$b$2201 [0] }
      New connections: $memory\m1.A$rdmux[3][2][1]$b$2201 [1] = $memory\m1.A$rdmux[3][3][1]$a$2212 [3]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[3][3][4]$2220:
      Old ports: A={ $memory\m1.A$rdmux[3][3][1]$a$2212 [1] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] }, B={ 1'1 $memory\m1.A$rdmux[3][3][1]$a$2212 [1] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] }, Y=$memory\m1.A$rdmux[3][2][2]$a$2203 [3:1]
      New ports: A={ $memory\m1.A$rdmux[3][3][1]$a$2212 [1] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] }, B={ 1'1 $memory\m1.A$rdmux[3][3][1]$a$2212 [1] }, Y=$memory\m1.A$rdmux[3][2][2]$a$2203 [3:2]
      New connections: $memory\m1.A$rdmux[3][2][2]$a$2203 [1] = $memory\m1.A$rdmux[3][3][1]$a$2212 [3]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][3][2]$2403:
      Old ports: A={ $memory\m1.A$rdmux[3][3][1]$a$2212 [1] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[3][3][1]$a$2212 [1] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] 1'0 }, Y=$memory\m1.A$rdmux[4][2][1]$a$2389 [3:0]
      New ports: A={ $memory\m1.A$rdmux[3][3][1]$a$2212 [1] $memory\m1.A$rdmux[3][3][1]$a$2212 [3] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[3][3][1]$a$2212 [1] 1'0 }, Y={ $memory\m1.A$rdmux[4][2][1]$a$2389 [3:2] $memory\m1.A$rdmux[4][2][1]$a$2389 [0] }
      New connections: $memory\m1.A$rdmux[4][2][1]$a$2389 [1] = $memory\m1.A$rdmux[3][3][1]$a$2212 [3]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[4][3][4]$2409:
      Old ports: A={ 2'01 $memory\m1.A$rdmux[3][3][0]$a$2209 [1] }, B={ 2'10 $memory\m1.A$rdmux[3][3][0]$a$2209 [1] }, Y=$memory\m1.A$rdmux[4][2][2]$a$2392 [3:1]
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[4][2][2]$a$2392 [3:2]
      New connections: $memory\m1.A$rdmux[4][2][2]$a$2392 [1] = $memory\m1.A$rdmux[3][3][0]$a$2209 [1]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][3][0]$2586:
      Old ports: A={ 1'0 $memory\m1.A$rdmux[1][3][0]$a$1831 [1] }, B={ 1'1 $memory\m1.A$rdmux[1][3][0]$a$1831 [1] }, Y=$memory\m1.A$rdmux[5][2][0]$a$2575 [2:1]
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[5][2][0]$a$2575 [2]
      New connections: $memory\m1.A$rdmux[5][2][0]$a$2575 [1] = $memory\m1.A$rdmux[1][3][0]$a$1831 [1]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][3][3]$2595:
      Old ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] 1'1 }, B={ $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] }, Y=$memory\m1.A$rdmux[5][2][1]$b$2579 [3:0]
      New ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] 1'1 }, B={ $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] }, Y={ $memory\m1.A$rdmux[5][2][1]$b$2579 [3:2] $memory\m1.A$rdmux[5][2][1]$b$2579 [0] }
      New connections: $memory\m1.A$rdmux[5][2][1]$b$2579 [1] = $memory\m1.A$rdmux[1][3][1]$a$1834 [3]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[5][3][4]$2598:
      Old ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] }, B={ 1'1 $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] }, Y=$memory\m1.A$rdmux[5][2][2]$a$2581 [3:1]
      New ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] }, B={ 1'1 $memory\m1.A$rdmux[1][3][1]$a$1834 [1] }, Y=$memory\m1.A$rdmux[5][2][2]$a$2581 [3:2]
      New connections: $memory\m1.A$rdmux[5][2][2]$a$2581 [1] = $memory\m1.A$rdmux[1][3][1]$a$1834 [3]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][3][2]$2781:
      Old ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] 1'0 }, Y=$memory\m1.A$rdmux[6][2][1]$a$2767 [3:0]
      New ports: A={ $memory\m1.A$rdmux[1][3][1]$a$1834 [1] $memory\m1.A$rdmux[1][3][1]$a$1834 [3] 1'1 }, B={ 1'0 $memory\m1.A$rdmux[1][3][1]$a$1834 [1] 1'0 }, Y={ $memory\m1.A$rdmux[6][2][1]$a$2767 [3:2] $memory\m1.A$rdmux[6][2][1]$a$2767 [0] }
      New connections: $memory\m1.A$rdmux[6][2][1]$a$2767 [1] = $memory\m1.A$rdmux[1][3][1]$a$1834 [3]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[6][3][4]$2787:
      Old ports: A={ 2'01 $memory\m1.A$rdmux[1][3][0]$a$1831 [1] }, B={ 2'10 $memory\m1.A$rdmux[1][3][0]$a$1831 [1] }, Y=$memory\m1.A$rdmux[6][2][2]$a$2770 [3:1]
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[6][2][2]$a$2770 [3:2]
      New connections: $memory\m1.A$rdmux[6][2][2]$a$2770 [1] = $memory\m1.A$rdmux[1][3][0]$a$1831 [1]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][3][0]$2964:
      Old ports: A={ 1'0 $memory\m1.A$rdmux[7][3][0]$a$2965 [1:0] }, B={ 1'1 $memory\m1.A$rdmux[7][3][0]$a$2965 [1:0] }, Y=$memory\m1.A$rdmux[7][2][0]$a$2953 [2:0]
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][2][0]$a$2953 [2]
      New connections: $memory\m1.A$rdmux[7][2][0]$a$2953 [1:0] = $memory\m1.A$rdmux[7][3][0]$a$2965 [1:0]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][0]$2988:
      Old ports: A={ 1'0 $memory\m1.A$rdmux[7][4][0]$a$2989 [0] }, B={ 1'1 $memory\m1.A$rdmux[7][4][0]$a$2989 [0] }, Y=$memory\m1.A$rdmux[7][3][0]$a$2965 [1:0]
      New ports: A=1'0, B=1'1, Y=$memory\m1.A$rdmux[7][3][0]$a$2965 [1]
      New connections: $memory\m1.A$rdmux[7][3][0]$a$2965 [0] = $memory\m1.A$rdmux[7][4][0]$a$2989 [0]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][3]$2997:
      Old ports: A={ $memory\m1.A$rdmux[7][4][2]$b$2996 [1:0] $memory\m1.A$rdmux[7][4][2]$b$2996 [0] }, B={ 1'1 $memory\m1.A$rdmux[7][4][2]$b$2996 [1:0] }, Y=$memory\m1.A$rdmux[7][3][1]$b$2969 [2:0]
      New ports: A=$memory\m1.A$rdmux[7][4][2]$b$2996 [1:0], B={ 1'1 $memory\m1.A$rdmux[7][4][2]$b$2996 [1] }, Y=$memory\m1.A$rdmux[7][3][1]$b$2969 [2:1]
      New connections: $memory\m1.A$rdmux[7][3][1]$b$2969 [0] = $memory\m1.A$rdmux[7][4][2]$b$2996 [0]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][4]$3000:
      Old ports: A={ $memory\m1.A$rdmux[7][4][2]$b$2996 [1:0] $memory\m1.A$rdmux[7][4][2]$b$2996 [0] $memory\m1.A$rdmux[7][4][2]$b$2996 [0] }, B={ 2'10 $memory\m1.A$rdmux[7][4][2]$b$2996 [1:0] }, Y=$memory\m1.A$rdmux[7][3][2]$a$2971 [3:0]
      New ports: A={ $memory\m1.A$rdmux[7][4][2]$b$2996 [1:0] $memory\m1.A$rdmux[7][4][2]$b$2996 [0] }, B={ 2'10 $memory\m1.A$rdmux[7][4][2]$b$2996 [1] }, Y=$memory\m1.A$rdmux[7][3][2]$a$2971 [3:1]
      New connections: $memory\m1.A$rdmux[7][3][2]$a$2971 [0] = $memory\m1.A$rdmux[7][4][2]$b$2996 [0]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][5]$3003:
      Old ports: A={ 2'01 $memory\m1.A$rdmux[7][4][0]$a$2989 [0] }, B={ 2'10 $memory\m1.A$rdmux[7][4][0]$a$2989 [0] }, Y=$memory\m1.A$rdmux[7][3][2]$b$2972 [2:0]
      New ports: A=2'01, B=2'10, Y=$memory\m1.A$rdmux[7][3][2]$b$2972 [2:1]
      New connections: $memory\m1.A$rdmux[7][3][2]$b$2972 [0] = $memory\m1.A$rdmux[7][4][0]$a$2989 [0]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][8]$3012:
      Old ports: A={ 2'01 $memory\m1.A$rdmux[7][4][2]$b$2996 [1:0] }, B={ $memory\m1.A$rdmux[7][4][2]$b$2996 [1:0] $memory\m1.A$rdmux[7][4][2]$b$2996 [0] $memory\m1.A$rdmux[7][4][2]$b$2996 [0] }, Y=$memory\m1.A$rdmux[7][3][4]$a$2977 [3:0]
      New ports: A={ 2'01 $memory\m1.A$rdmux[7][4][2]$b$2996 [1] }, B={ $memory\m1.A$rdmux[7][4][2]$b$2996 [1:0] $memory\m1.A$rdmux[7][4][2]$b$2996 [0] }, Y=$memory\m1.A$rdmux[7][3][4]$a$2977 [3:1]
      New connections: $memory\m1.A$rdmux[7][3][4]$a$2977 [0] = $memory\m1.A$rdmux[7][4][2]$b$2996 [0]
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][4][9]$3015:
      Old ports: A={ 1'0 $memory\m1.A$rdmux[7][4][2]$b$2996 [1:0] }, B={ $memory\m1.A$rdmux[7][4][2]$b$2996 [1:0] $memory\m1.A$rdmux[7][4][2]$b$2996 [0] }, Y=$memory\m1.A$rdmux[7][3][4]$b$2978 [2:0]
      New ports: A={ 1'0 $memory\m1.A$rdmux[7][4][2]$b$2996 [1] }, B=$memory\m1.A$rdmux[7][4][2]$b$2996 [1:0], Y=$memory\m1.A$rdmux[7][3][4]$b$2978 [2:1]
      New connections: $memory\m1.A$rdmux[7][3][4]$b$2978 [0] = $memory\m1.A$rdmux[7][4][2]$b$2996 [0]
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][1][0]$3470:
      Old ports: A={ 1'0 $memory\m1.B$rdmux[7][1][0]$a$3471 [1:0] }, B={ 1'1 $memory\m1.B$rdmux[7][1][0]$a$3471 [1:0] }, Y=$memory\m1.B$rdmux[7][0][0]$a$3468 [2:0]
      New ports: A=1'0, B=1'1, Y=$memory\m1.B$rdmux[7][0][0]$a$3468 [2]
      New connections: $memory\m1.B$rdmux[7][0][0]$a$3468 [1:0] = $memory\m1.B$rdmux[7][1][0]$a$3471 [1:0]
    Consolidated identical input bits for $mux cell $memory\m1.B$rdmux[7][2][0]$3476:
      Old ports: A={ 1'0 $memory\m1.B$rdmux[7][2][0]$a$3477 [0] }, B={ 1'1 $memory\m1.B$rdmux[7][2][0]$a$3477 [0] }, Y=$memory\m1.B$rdmux[7][1][0]$a$3471 [1:0]
      New ports: A=1'0, B=1'1, Y=$memory\m1.B$rdmux[7][1][0]$a$3471 [1]
      New connections: $memory\m1.B$rdmux[7][1][0]$a$3471 [0] = $memory\m1.B$rdmux[7][2][0]$a$3477 [0]
  Optimizing cells in module \top.
    Consolidated identical input bits for $mux cell $memory\m1.A$rdmux[7][3][4]$2976:
      Old ports: A=$memory\m1.A$rdmux[7][3][4]$a$2977 [3:0], B={ 1'1 $memory\m1.A$rdmux[7][3][4]$b$2978 [2:0] }, Y=$memory\m1.A$rdmux[7][2][2]$a$2959 [3:0]
      New ports: A=$memory\m1.A$rdmux[7][3][4]$a$2977 [3:1], B={ 1'1 $memory\m1.A$rdmux[7][3][4]$b$2978 [2:1] }, Y=$memory\m1.A$rdmux[7][2][2]$a$2959 [3:1]
      New connections: $memory\m1.A$rdmux[7][2][2]$a$2959 [0] = $memory\m1.A$rdmux[7][4][2]$b$2996 [0]
  Optimizing cells in module \top.
Performed a total of 28 changes.

3.36.19. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.36.20. Executing OPT_DFF pass (perform DFF optimizations).
Setting constant 0-bit at position 0 on $\m1.B$rdreg[6] ($dff) from module top.
Setting constant 0-bit at position 1 on $\m1.B$rdreg[6] ($dff) from module top.
Setting constant 0-bit at position 2 on $\m1.B$rdreg[6] ($dff) from module top.
Setting constant 0-bit at position 4 on $\m1.B$rdreg[6] ($dff) from module top.
Setting constant 0-bit at position 5 on $\m1.B$rdreg[6] ($dff) from module top.
Setting constant 0-bit at position 6 on $\m1.B$rdreg[6] ($dff) from module top.
Setting constant 0-bit at position 7 on $\m1.B$rdreg[6] ($dff) from module top.

3.36.21. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 0 unused cells and 7 unused wires.
<suppressed ~1 debug messages>

3.36.22. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.36.23. Rerunning OPT passes. (Maybe there is more to do..)

3.36.24. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~43 debug messages>

3.36.25. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top.
Performed a total of 0 changes.

3.36.26. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.36.27. Executing OPT_DFF pass (perform DFF optimizations).

3.36.28. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

3.36.29. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.36.30. Finished OPT passes. (There is nothing left to do.)

3.37. Executing ICE40_WRAPCARRY pass (wrap carries).

3.38. Executing TECHMAP pass (map to technology primitives).

3.38.1. Executing Verilog-2005 frontend: /home/mahesh/oss-cad-suite/lib/../share/yosys/techmap.v
Parsing Verilog input from `/home/mahesh/oss-cad-suite/lib/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.38.2. Executing Verilog-2005 frontend: /home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/arith_map.v
Parsing Verilog input from `/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/arith_map.v' to AST representation.
Generating RTLIL representation for module `\_80_ice40_alu'.
Successfully finished Verilog frontend.

3.38.3. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $reduce_and.
Using extmapper simplemap for cells of type $reduce_bool.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $and.
Using template $paramod$78e969f2586efcf3a5b0b0440bcca0db83d5cca2\_80_ice40_alu for cells of type $alu.
Using extmapper simplemap for cells of type $dff.
Using extmapper simplemap for cells of type $dffe.
Using extmapper simplemap for cells of type $eq.
Using extmapper maccmap for cells of type $macc.
  add \m1.row_index * 3'101 (3x3 bits, unsigned)
Using extmapper simplemap for cells of type $or.
Using template $paramod$a950948e19702336540a1f557d0a91306bdb9188\_80_ice40_alu for cells of type $alu.
  add { $techmap1342$flatten\m1.$mul$matmul.v:0$495.Y 1'0 } (6 bits, unsigned)
  add \m1.index [5:0] (6 bits, unsigned)
  add 6'001000 (6 bits, unsigned)
Using extmapper simplemap for cells of type $sdffe.
Using extmapper simplemap for cells of type $ne.
Using template $paramod$fbc7873bff55778c0b3173955b7e4bce1d9d6834\_80_ice40_alu for cells of type $alu.
Using template $paramod$8fabc56b80a569262acfc42757a02ca0b8e91278\_90_pmux for cells of type $pmux.
Using template $paramod$c3cd1564c35d873179656addd6052d7ea8b6d991\_80_ice40_alu for cells of type $alu.
Using template $paramod$fc16b9f758000d363d24f130038bd99b46b4fa1b\_90_pmux for cells of type $pmux.
Using template $paramod$3ef7d3dd227da7627a99c5e5a6a4deb817573e39\_80_ice40_alu for cells of type $alu.
  add \m1.sum[0] (32 bits, unsigned)
  add \m1.sum[4] (32 bits, unsigned)
  add \m1.sum[2] (32 bits, unsigned)
  add \m1.sum[1] (32 bits, unsigned)
  add \m1.sum[6] (32 bits, unsigned)
  add \m1.sum[5] (32 bits, unsigned)
  add \m1.sum[3] (32 bits, unsigned)
  add \m1.sum[7] (32 bits, unsigned)
Using template $paramod$fc972a7a46956c1788f3cb5257b53c8f1df2d0cc\_90_alu for cells of type $alu.
Using template $paramod$38e8498ccdc425801fe5312e427e3cf0d9089c58\_80_ice40_alu for cells of type $alu.
Using template $paramod$b18e16801adf491a64caa0542270798e5d4ac6b6\_80_ice40_alu for cells of type $alu.
Using template $paramod$740b056ede97228d3eae64ea2fdc81f0a33e0fe7\_80_ice40_alu for cells of type $alu.
Using extmapper simplemap for cells of type $pos.
Using template $paramod\_90_lcu\WIDTH=32'00000000000000000000000000000001 for cells of type $lcu.
Using template $paramod\_90_fa\WIDTH=32'00000000000000000000000000000101 for cells of type $fa.
Using template $paramod\_90_fa\WIDTH=32'00000000000000000000000000000110 for cells of type $fa.
Using template $paramod$00298f3f8094950cb9a5ff2fda48d0d8bde8806c\_80_ice40_alu for cells of type $alu.
Using extmapper simplemap for cells of type $xor.
Using template $paramod\_90_fa\WIDTH=32'00000000000000000000000000100000 for cells of type $fa.
No more expansions possible.
<suppressed ~859 debug messages>

3.39. Executing OPT pass (performing simple optimizations).

3.39.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~949 debug messages>

3.39.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
<suppressed ~414 debug messages>
Removed a total of 138 cells.

3.39.3. Executing OPT_DFF pass (perform DFF optimizations).

3.39.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 375 unused cells and 666 unused wires.
<suppressed ~376 debug messages>

3.39.5. Finished fast OPT passes.

3.40. Executing ICE40_OPT pass (performing simple optimizations).

3.40.1. Running ICE40 specific optimizations.
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$alumacc.cc:485:replace_alu$1388.slice[0].carry: CO=$auto$alumacc.cc:485:replace_alu$1388.BB [0]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$alumacc.cc:485:replace_alu$1399.slice[0].carry: CO=\resetn_counter [0]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$alumacc.cc:485:replace_alu$1408.slice[0].carry: CO=$auto$alumacc.cc:485:replace_alu$1408.B [0]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$alumacc.cc:485:replace_alu$1414.slice[0].carry: CO=$auto$alumacc.cc:485:replace_alu$1408.B [1]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$alumacc.cc:485:replace_alu$1420.slice[0].carry: CO=$auto$alumacc.cc:485:replace_alu$1408.B [0]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$alumacc.cc:485:replace_alu$1471.slice[0].carry: CO=$auto$alumacc.cc:485:replace_alu$1388.BB [1]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$alumacc.cc:485:replace_alu$1482.slice[0].carry: CO=\m1.index [0]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$alumacc.cc:485:replace_alu$1491.slice[0].carry: CO=\m1.row_index [0]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$maccmap.cc:240:synth$3946.slice[0].carry: CO=1'0
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$maccmap.cc:240:synth$3990.slice[0].carry: CO=1'0
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$maccmap.cc:240:synth$4753.slice[0].carry: CO=1'0

3.40.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~85 debug messages>

3.40.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
<suppressed ~6 debug messages>
Removed a total of 2 cells.

3.40.4. Executing OPT_DFF pass (perform DFF optimizations).
Adding SRST signal on $auto$ff.cc:262:slice$3838 ($_DFF_P_) from module top (D = $auto$rtlil.cc:2459:Mux$1330 [3], Q = $techmap1341$flatten\m1.$mul$matmul.v:109$502.B [3], rval = 1'0).

3.40.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 3 unused cells and 19 unused wires.
<suppressed ~4 debug messages>

3.40.6. Rerunning OPT passes. (Removed registers in this run.)

3.40.7. Running ICE40 specific optimizations.
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$maccmap.cc:240:synth$3946.slice[1].carry: CO=1'0
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$maccmap.cc:240:synth$3990.slice[1].carry: CO=1'0
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$maccmap.cc:240:synth$4753.slice[1].carry: CO=1'0

3.40.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.40.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.40.10. Executing OPT_DFF pass (perform DFF optimizations).

3.40.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

3.40.12. Rerunning OPT passes. (Removed registers in this run.)

3.40.13. Running ICE40 specific optimizations.
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top.$auto$maccmap.cc:240:synth$3946.slice[2].carry: CO=1'0

3.40.14. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.40.15. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.40.16. Executing OPT_DFF pass (perform DFF optimizations).

3.40.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

3.40.18. Rerunning OPT passes. (Removed registers in this run.)

3.40.19. Running ICE40 specific optimizations.

3.40.20. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.40.21. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.40.22. Executing OPT_DFF pass (perform DFF optimizations).

3.40.23. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

3.40.24. Finished OPT passes. (There is nothing left to do.)

3.41. Executing DFFLEGALIZE pass (convert FFs to types supported by the target).

3.42. Executing TECHMAP pass (map to technology primitives).

3.42.1. Executing Verilog-2005 frontend: /home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/ff_map.v
Parsing Verilog input from `/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/ff_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$_DFFE_NP0P_'.
Generating RTLIL representation for module `\$_DFFE_NP1P_'.
Generating RTLIL representation for module `\$_DFFE_PP0P_'.
Generating RTLIL representation for module `\$_DFFE_PP1P_'.
Generating RTLIL representation for module `\$_SDFF_NP0_'.
Generating RTLIL representation for module `\$_SDFF_NP1_'.
Generating RTLIL representation for module `\$_SDFF_PP0_'.
Generating RTLIL representation for module `\$_SDFF_PP1_'.
Generating RTLIL representation for module `\$_SDFFCE_NP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_NP1P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP1P_'.
Successfully finished Verilog frontend.

3.42.2. Continuing TECHMAP pass.
Using template \$_SDFFCE_PP0P_ for cells of type $_SDFFCE_PP0P_.
Using template \$_DFFE_PP_ for cells of type $_DFFE_PP_.
Using template \$_SDFF_PP0_ for cells of type $_SDFF_PP0_.
Using template \$_DFF_P_ for cells of type $_DFF_P_.
No more expansions possible.
<suppressed ~335 debug messages>

3.43. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.44. Executing SIMPLEMAP pass (map simple cells to gate primitives).
Mapping top.$auto$alumacc.cc:485:replace_alu$1399.slice[0].carry ($lut).
Mapping top.$auto$alumacc.cc:485:replace_alu$1414.slice[0].carry ($lut).
Mapping top.$auto$alumacc.cc:485:replace_alu$1420.slice[0].carry ($lut).
Mapping top.$auto$alumacc.cc:485:replace_alu$1482.slice[0].carry ($lut).
Mapping top.$auto$alumacc.cc:485:replace_alu$1491.slice[0].carry ($lut).
Mapping top.$auto$maccmap.cc:240:synth$3946.slice[0].carry ($lut).
Mapping top.$auto$maccmap.cc:240:synth$3946.slice[1].carry ($lut).
Mapping top.$auto$maccmap.cc:240:synth$3946.slice[2].carry ($lut).
Mapping top.$auto$maccmap.cc:240:synth$3990.slice[0].carry ($lut).
Mapping top.$auto$maccmap.cc:240:synth$3990.slice[1].carry ($lut).
Mapping top.$auto$maccmap.cc:240:synth$4753.slice[0].carry ($lut).
Mapping top.$auto$maccmap.cc:240:synth$4753.slice[1].carry ($lut).

3.45. Executing ICE40_OPT pass (performing simple optimizations).

3.45.1. Running ICE40 specific optimizations.

3.45.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.
<suppressed ~207 debug messages>

3.45.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
<suppressed ~1887 debug messages>
Removed a total of 629 cells.

3.45.4. Executing OPT_DFF pass (perform DFF optimizations).

3.45.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..
Removed 3 unused cells and 2520 unused wires.
<suppressed ~4 debug messages>

3.45.6. Rerunning OPT passes. (Removed registers in this run.)

3.45.7. Running ICE40 specific optimizations.

3.45.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top.

3.45.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top'.
Removed a total of 0 cells.

3.45.10. Executing OPT_DFF pass (perform DFF optimizations).

3.45.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top..

3.45.12. Finished OPT passes. (There is nothing left to do.)

3.46. Executing TECHMAP pass (map to technology primitives).

3.46.1. Executing Verilog-2005 frontend: /home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/latches_map.v
Parsing Verilog input from `/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/latches_map.v' to AST representation.
Generating RTLIL representation for module `\$_DLATCH_N_'.
Generating RTLIL representation for module `\$_DLATCH_P_'.
Successfully finished Verilog frontend.

3.46.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~4 debug messages>

3.47. Executing ABC pass (technology mapping using ABC).

3.47.1. Extracting gate netlist of module `\top' to `<abc-temp-dir>/input.blif'..
Extracted 1584 gates and 2247 wires to a netlist network with 661 inputs and 426 outputs.

3.47.1.1. Executing ABC.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: + lutpack -S 1 
ABC: + dress 
ABC: Total number of equiv classes                =     773.
ABC: Participating nodes from both networks       =    1564.
ABC: Participating nodes from the first network   =     775. (  95.44 % of nodes)
ABC: Participating nodes from the second network  =     789. (  97.17 % of nodes)
ABC: Node pairs (any polarity)                    =     775. (  95.44 % of names can be moved)
ABC: Node pairs (same polarity)                   =     612. (  75.37 % of names can be moved)
ABC: Total runtime =     0.05 sec
ABC: + write_blif <abc-temp-dir>/output.blif 

3.47.1.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:      811
ABC RESULTS:        internal signals:     1160
ABC RESULTS:           input signals:      661
ABC RESULTS:          output signals:      426
Removing temp directory.

3.48. Executing ICE40_WRAPCARRY pass (wrap carries).

3.49. Executing TECHMAP pass (map to technology primitives).

3.49.1. Executing Verilog-2005 frontend: /home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/ff_map.v
Parsing Verilog input from `/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/ff_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$_DFFE_NP0P_'.
Generating RTLIL representation for module `\$_DFFE_NP1P_'.
Generating RTLIL representation for module `\$_DFFE_PP0P_'.
Generating RTLIL representation for module `\$_DFFE_PP1P_'.
Generating RTLIL representation for module `\$_SDFF_NP0_'.
Generating RTLIL representation for module `\$_SDFF_NP1_'.
Generating RTLIL representation for module `\$_SDFF_PP0_'.
Generating RTLIL representation for module `\$_SDFF_PP1_'.
Generating RTLIL representation for module `\$_SDFFCE_NP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_NP1P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP0P_'.
Generating RTLIL representation for module `\$_SDFFCE_PP1P_'.
Successfully finished Verilog frontend.

3.49.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~22 debug messages>
Removed 32 unused cells and 999 unused wires.

3.50. Executing OPT_LUT pass (optimize LUTs).
Discovering LUTs.
Number of LUTs:     1165
  1-LUT               12
  2-LUT              345
  3-LUT              642
  4-LUT              166
  with \SB_CARRY    (#0)  337
  with \SB_CARRY    (#1)  337

Eliminating LUTs.
Number of LUTs:     1165
  1-LUT               12
  2-LUT              345
  3-LUT              642
  4-LUT              166
  with \SB_CARRY    (#0)  337
  with \SB_CARRY    (#1)  337

Combining LUTs.
Number of LUTs:      898
  1-LUT               12
  2-LUT               68
  3-LUT              395
  4-LUT              423
  with \SB_CARRY    (#0)  337
  with \SB_CARRY    (#1)  337

Eliminated 0 LUTs.
Combined 267 LUTs.
<suppressed ~8000 debug messages>

3.51. Executing TECHMAP pass (map to technology primitives).

3.51.1. Executing Verilog-2005 frontend: /home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/home/mahesh/oss-cad-suite/lib/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$lut'.
Successfully finished Verilog frontend.

3.51.2. Continuing TECHMAP pass.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0110 for cells of type $lut.
Using template $paramod$fd904e9e35cfd343a9df248824bd3f1408724879\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'1000 for cells of type $lut.
Using template $paramod$8c24dc0cdd336b7fb88bbf7eed45cec5cbae862b\$lut for cells of type $lut.
Using template $paramod$555d8894a5dc879d4aaf105acda69d0f917bfc10\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000001\LUT=2'01 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10010110 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00010111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00101011 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0001 for cells of type $lut.
Using template $paramod$0de052767abdccc3aefc818722bdc3c7850d25d6\$lut for cells of type $lut.
Using template $paramod$658b9ed803f0d3d335616d3858b53e0a2522f1e8\$lut for cells of type $lut.
Using template $paramod$6cdcdffb7f2536598ad1b78cf02ad7d5776e11e4\$lut for cells of type $lut.
Using template $paramod$571404c0889eaf57f492cb5e37f8acb5df5852f9\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'1110 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00110101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'1011 for cells of type $lut.
Using template $paramod$5858bd6d78d6f4fef506811d9419710ec77e5fb5\$lut for cells of type $lut.
Using template $paramod$82f6ddafa699a94a5d0125aa616c72ec08094bfe\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'1001 for cells of type $lut.
Using template $paramod$f3e91f2f114ffa356d6c3aaaa108f5d9018f89d3\$lut for cells of type $lut.
Using template $paramod$9843d77d4773ab424562cc9655d50a1bc2125488\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'01101001 for cells of type $lut.
Using template $paramod$4282def8dbd6df3d1248ad282c629bee684502c2\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000010\LUT=4'0111 for cells of type $lut.
Using template $paramod$6b0849254d6c87461fb93e37cc18f089f61eb912\$lut for cells of type $lut.
Using template $paramod$2f99e7dde0142f5eb4336d05fd90a596d3f2e038\$lut for cells of type $lut.
Using template $paramod$e5cb8e913f4daae476fde2b364998f21967f1f08\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'01110001 for cells of type $lut.
Using template $paramod$de130a14fc9f751c7ce94619fc4863baab751a79\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'01010011 for cells of type $lut.
Using template $paramod$595b4955041ceff09e28d600fe79275c24ba9878\$lut for cells of type $lut.
Using template $paramod$6d6beead1425af15cf78b27fd9b11b41b5d4bce8\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00000111 for cells of type $lut.
Using template $paramod$a59507d273cd827eb6c46c37820d50a1b717efdf\$lut for cells of type $lut.
Using template $paramod$e9c77024ca501b890c641f9c0b10e27242db8730\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'01001011 for cells of type $lut.
Using template $paramod$1bc921318dd5ecb49726edaf90bec555caf30b67\$lut for cells of type $lut.
Using template $paramod$59c595af41d4a5cce2d588c3a5f1342749ce7a77\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'01110000 for cells of type $lut.
Using template $paramod$c9bd95cb53d4d2677a14e71f93bb3d8392b19cfd\$lut for cells of type $lut.
Using template $paramod$933f4f3e373a784da64d137def3625bdd36d1695\$lut for cells of type $lut.
Using template $paramod$1644affdabe7f65febd25ca1c4d1e050be54e54f\$lut for cells of type $lut.
Using template $paramod$d76856c88fdca5609a1600b549559282bda8a7dc\$lut for cells of type $lut.
Using template $paramod$19ec49f31a8d230a567aa44ce3ea81a03c101e2b\$lut for cells of type $lut.
Using template $paramod$12879138d1e376f344e47ea40be66b776233be75\$lut for cells of type $lut.
Using template $paramod$ab09a333f81eda6e35cf6d6f98b1b54b33c62f58\$lut for cells of type $lut.
Using template $paramod$7fcc2f13195f27c397064377984d87a90c06749d\$lut for cells of type $lut.
Using template $paramod$5280a6fb15b184512b48cc6d199288a0bfdcb7a5\$lut for cells of type $lut.
Using template $paramod$7bcf8a0acb4facd1dfe70d22caec4edc2292bba2\$lut for cells of type $lut.
Using template $paramod$81d8a60fd95b1a9f9ef71c12a774ae6988cb9fd5\$lut for cells of type $lut.
Using template $paramod$dd2e18722952b962be9c3488687de11733794dd4\$lut for cells of type $lut.
Using template $paramod$240307bbace6557f3d46ac64c87ca4d697801fc3\$lut for cells of type $lut.
Using template $paramod$df0b68f8e63b2deb6710e23abd8b8ff0796d4897\$lut for cells of type $lut.
Using template $paramod$6f625205336ac6ce7b8747324becdbce1049bc9c\$lut for cells of type $lut.
Using template $paramod$765dca61dbfa835dacf2a260c8a4c5a36939a046\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00010000 for cells of type $lut.
Using template $paramod$a50be0e6fa3a01511bb234559cb74fb8bd3e2061\$lut for cells of type $lut.
Using template $paramod$c24ed72ebb67e9ead6029e42e909ef7fc0abbb11\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10000011 for cells of type $lut.
Using template $paramod$1198f6812452c0689f88f5b56c3a810314c8a509\$lut for cells of type $lut.
Using template $paramod$ffb5bd8ac626eda1cc3e9ebac1f7d90cd23e95fe\$lut for cells of type $lut.
Using template $paramod$89ecc988e7f3a243ddc8cc8f07da68413562d454\$lut for cells of type $lut.
Using template $paramod$c8f8de1e282c2efd965273401aa185ed4174dfce\$lut for cells of type $lut.
Using template $paramod$332a399730bfc61adea04021a76b1c4e4030f37d\$lut for cells of type $lut.
Using template $paramod$11ec7271d8e6e5aeaace08c13e4c601f10e31038\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10100011 for cells of type $lut.
Using template $paramod$f6718da5409ec8636fab31113c774a3123f56b0b\$lut for cells of type $lut.
Using template $paramod$44322768708ea1617c4f8f4845eb883e6765da22\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10101100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'10110100 for cells of type $lut.
Using template $paramod$3e8d0aa900463bbdc955d11c0603f5479307c386\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11100001 for cells of type $lut.
Using template $paramod$348ced7bf8801e3190af0eb3d166b5ae31f33183\$lut for cells of type $lut.
Using template $paramod$e7757b2d317771cca578effc1d1433759b825f83\$lut for cells of type $lut.
Using template $paramod$1a80d0938ff0c277d428709ca14f3e1c132d5c6e\$lut for cells of type $lut.
Using template $paramod$ee24e932b1be25a160b7496e6b0c7f5cc8e6a6ec\$lut for cells of type $lut.
Using template $paramod$0d71ccb5a2c3ff9094522b5a6b3fb7bbc8ad4909\$lut for cells of type $lut.
Using template $paramod$c471af5667a682bd131a5b479e58e470d1b2b7cd\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'01011100 for cells of type $lut.
Using template $paramod$a4df2b5be2b644499880e088a11556935f22b401\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00111010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'00011100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'01000011 for cells of type $lut.
Using template $paramod$06effc70d6b09a40fe0953589de086c272e03a84\$lut for cells of type $lut.
Using template $paramod$19a92eaa3123729a9edc49004071fabd5671a107\$lut for cells of type $lut.
Using template $paramod$4cf5305612d86489c1a6171729557670bf08582e\$lut for cells of type $lut.
Using template $paramod$ae2167737e884e455e0dc9c6a1bfb0669403f070\$lut for cells of type $lut.
Using template $paramod$e0bde73e598487237493c8a43ca52c95a3727354\$lut for cells of type $lut.
Using template $paramod$1defcde2651b9293b25dc8313a52210a02d52398\$lut for cells of type $lut.
Using template $paramod$69f20e0703606f2ffd2ee27cd26f815bd5eeb6e9\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=32'00000000000000000000000000000011\LUT=8'11111000 for cells of type $lut.
Using template $paramod$d0bf26260eea0e8530fb2e72eb38c60e28a47da8\$lut for cells of type $lut.
Using template $paramod$7ad53a9b58976a4fa60dc0c25fbea8aa88991eef\$lut for cells of type $lut.
Using template $paramod$c5b694ec89d7629b942ccf6a9be1d39e24f8edec\$lut for cells of type $lut.
Using template $paramod$5a621b016c894274d07edef48c49b401a15fd796\$lut for cells of type $lut.
Using template $paramod$45d617c2ce0041e27b541f62b0fc3c3ce441a616\$lut for cells of type $lut.
Using template $paramod$9d707d218adbd63b6f9a0c79d7ee037306fb6296\$lut for cells of type $lut.
No more expansions possible.
<suppressed ~2201 debug messages>
Removed 0 unused cells and 2018 unused wires.

3.52. Executing AUTONAME pass.
Renamed 44559 objects in module top (86 iterations).
<suppressed ~2099 debug messages>

3.53. Executing HIERARCHY pass (managing design hierarchy).

3.53.1. Analyzing design hierarchy..
Top module:  \top

3.53.2. Analyzing design hierarchy..
Top module:  \top
Removed 0 unused modules.

3.54. Printing statistics.

=== top ===

   Number of wires:                602
   Number of wire bits:           2714
   Number of public wires:         602
   Number of public wire bits:    2714
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               1567
     SB_CARRY                      348
     SB_DFF                          5
     SB_DFFE                         8
     SB_DFFESR                     299
     SB_DFFSR                        1
     SB_LUT4                       898
     SB_MAC16                        8

3.55. Executing CHECK pass (checking for obvious problems).
Checking module top...
Found and reported 0 problems.

3.56. Executing JSON backend.

Warnings: 1 unique messages, 1 total
End of script. Logfile hash: 92cc2dc182, CPU: user 1.89s system 0.05s, MEM: 56.18 MB peak
Yosys 0.15+40 (git sha1 e1d4863a1, clang 10.0.0-4ubuntu1 -fPIC -Os)
Time spent: 21% 31x opt_expr (0 sec), 21% 1x abc (0 sec), ...
